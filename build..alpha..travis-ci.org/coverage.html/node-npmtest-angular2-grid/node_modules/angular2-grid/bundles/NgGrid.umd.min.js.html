<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-angular2-grid/node_modules/angular2-grid/bundles/NgGrid.umd.min.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-angular2-grid">npmtest-angular2-grid (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-angular2-grid/node_modules/angular2-grid/bundles/NgGrid.umd.min.js</span></h1>
    <h2>
        
        Statements: <span class="metric">3.77% <small>(18 / 477)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0.44% <small>(3 / 688)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">8.76% <small>(12 / 137)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(2 / 2)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-angular2-grid/node_modules/angular2-grid/bundles/</a> &#187; NgGrid.umd.min.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3</td><td class="line-coverage"><span class="cline-any cline-yes">8</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">!function(t,i){"object"==typeof exports&amp;&amp;"undefined"!=typeof module?i(exports,require("@angular/core")):<span class="branch-1 cbranch-no" title="branch not covered" >"function"==typeof define&amp;&amp;define.amd?define(["exports","@angular/core"],i):i((t.ng=t.ng||{},t.ng.grid=t.ng.grid||{}),t.ng.core)}</span>(this,function(t,i){"use strict";var e=function(){<span class="fstat-no" title="function not covered" >function t(t,i){<span class="cstat-no" title="statement not covered" ></span>this._ngEl=t,this._renderer=i}</span>return t.prototype.registerGrid=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._ngGrid=t}</span>,t.prototype.ngOnInit=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._renderer.setElementClass(this._ngEl.nativeElement,"grid-placeholder",!0),this._ngGrid.autoStyle&amp;&amp;this._renderer.setElementStyle(this._ngEl.nativeElement,"position","absolute")}</span>,t.prototype.setSize=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._size=t,this._recalculateDimensions()}</span>,t.prototype.setGridPosition=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._position=t,this._recalculatePosition()}</span>,t.prototype.setCascadeMode=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>switch(this._cascadeMode=t,t){case"up":case"left":default:<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"left","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"top","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"right",null),this._renderer.setElementStyle(this._ngEl.nativeElement,"bottom",null);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"right","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"top","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"left",null),this._renderer.setElementStyle(this._ngEl.nativeElement,"bottom",null);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"down":<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"left","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"bottom","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"right",null),this._renderer.setElementStyle(this._ngEl.nativeElement,"top",null)}</span>}</span>,t.prototype._setDimensions=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>this._renderer.setElementStyle(this._ngEl.nativeElement,"width",t+"px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"height",i+"px")}</span>,t.prototype._setPosition=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>switch(this._cascadeMode){case"up":case"left":default:<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"transform","translate("+t+"px, "+i+"px)");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"transform","translate("+-t+"px, "+i+"px)");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"down":<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"transform","translate("+t+"px, "+-i+"px)")}</span>}</span>,t.prototype._recalculatePosition=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=(this._ngGrid.colWidth+this._ngGrid.marginLeft+this._ngGrid.marginRight)*(this._position.col-1)+this._ngGrid.marginLeft,i=(this._ngGrid.rowHeight+this._ngGrid.marginTop+this._ngGrid.marginBottom)*(this._position.row-1)+this._ngGrid.marginTop;<span class="cstat-no" title="statement not covered" >t</span>his._setPosition(t,i)}</span>,t.prototype._recalculateDimensions=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=this._ngGrid.colWidth*this._size.x+(this._ngGrid.marginLeft+this._ngGrid.marginRight)*(this._size.x-1),i=this._ngGrid.rowHeight*this._size.y+(this._ngGrid.marginTop+this._ngGrid.marginBottom)*(this._size.y-1);<span class="cstat-no" title="statement not covered" >t</span>his._setDimensions(t,i)}</span>,t.decorators=[{type:i.Component,args:[{selector:"ng-grid-placeholder",template:""}]}],t.ctorParameters=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return[{type:i.ElementRef},{type:i.Renderer}]}</span>,t}(),s=function(){<span class="fstat-no" title="function not covered" >function t(e,s,n,o,r){<span class="cstat-no" title="statement not covered" ></span>this._differs=e,this._ngEl=s,this._renderer=n,this.componentFactoryResolver=o,this._containerRef=r,this.onDragStart=new i.EventEmitter,this.onDrag=new i.EventEmitter,this.onDragStop=new i.EventEmitter,this.onResizeStart=new i.EventEmitter,this.onResize=new i.EventEmitter,this.onResizeStop=new i.EventEmitter,this.onItemChange=new i.EventEmitter,this.colWidth=250,this.rowHeight=250,this.minCols=1,this.minRows=1,this.marginTop=10,this.marginRight=10,this.marginBottom=10,this.marginLeft=10,this.isDragging=!1,this.isResizing=!1,this.autoStyle=!0,this.resizeEnable=!0,this.dragEnable=!0,this.cascade="up",this.minWidth=100,this.minHeight=100,this._items=[],this._draggingItem=null,this._resizingItem=null,this._resizeDirection=null,this._itemGrid={},this._maxCols=0,this._maxRows=0,this._visibleCols=0,this._visibleRows=0,this._setWidth=250,this._setHeight=250,this._posOffset=null,this._adding=!1,this._placeholderRef=null,this._fixToGrid=!1,this._autoResize=!1,this._destroyed=!1,this._maintainRatio=!1,this._preferNew=!1,this._zoomOnDrag=!1,this._limitToScreen=!1,this._curMaxRow=0,this._curMaxCol=0,this._dragReady=!1,this._resizeReady=!1,this._config=t.CONST_DEFAULT_CONFIG}</span>return Object.defineProperty(t.prototype,"config",{set:<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this.setConfig(t),null==this._differ&amp;&amp;null!=t&amp;&amp;(this._differ=this._differs.find(this._config).create(null))}</span>,enumerable:!0,configurable:!0}),t.prototype.ngOnInit=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._renderer.setElementClass(this._ngEl.nativeElement,"grid",!0),this.autoStyle&amp;&amp;this._renderer.setElementStyle(this._ngEl.nativeElement,"position","relative"),this.setConfig(this._config)}</span>,t.prototype.ngOnDestroy=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._destroyed=!0}</span>,t.prototype.setConfig=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._config=t;<span class="cstat-no" title="statement not covered" >v</span>ar i=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var e in t){<span class="cstat-no" title="statement not covered" >var s=t[e],n=s?parseInt(s):0;<span class="cstat-no" title="statement not covered" >s</span>witch(e){case"margins":<span class="cstat-no" title="statement not covered" >this.setMargins(s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"col_width":<span class="cstat-no" title="statement not covered" >this.colWidth=Math.max(n,1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"row_height":<span class="cstat-no" title="statement not covered" >this.rowHeight=Math.max(n,1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"auto_style":<span class="cstat-no" title="statement not covered" >this.autoStyle=!!s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"auto_resize":<span class="cstat-no" title="statement not covered" >this._autoResize=!!s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"draggable":<span class="cstat-no" title="statement not covered" >this.dragEnable=!!s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"resizable":<span class="cstat-no" title="statement not covered" >this.resizeEnable=!!s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"max_rows":<span class="cstat-no" title="statement not covered" >i=i||this._maxRows!=n,this._maxRows=n&lt;0?0:n;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"max_cols":<span class="cstat-no" title="statement not covered" >i=i||this._maxCols!=n,this._maxCols=n&lt;0?0:n;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"visible_rows":<span class="cstat-no" title="statement not covered" >this._visibleRows=Math.max(n,0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"visible_cols":<span class="cstat-no" title="statement not covered" >this._visibleCols=Math.max(n,0);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"min_rows":<span class="cstat-no" title="statement not covered" >this.minRows=Math.max(n,1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"min_cols":<span class="cstat-no" title="statement not covered" >this.minCols=Math.max(n,1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"min_height":<span class="cstat-no" title="statement not covered" >this.minHeight=Math.max(n,1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"min_width":<span class="cstat-no" title="statement not covered" >this.minWidth=Math.max(n,1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"zoom_on_drag":<span class="cstat-no" title="statement not covered" >this._zoomOnDrag=!!s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"cascade":<span class="cstat-no" title="statement not covered" >this.cascade!=s&amp;&amp;(this.cascade=s,this._cascadeGrid());<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"fix_to_grid":<span class="cstat-no" title="statement not covered" >this._fixToGrid=!!s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"maintain_ratio":<span class="cstat-no" title="statement not covered" >this._maintainRatio=!!s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"prefer_new":<span class="cstat-no" title="statement not covered" >this._preferNew=!!s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"limit_to_screen":<span class="cstat-no" title="statement not covered" >this._limitToScreen=!!s}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this._maintainRatio&amp;&amp;(this.colWidth&amp;&amp;this.rowHeight?this._aspectRatio=this.colWidth/this.rowHeight:this._maintainRatio=!1),i){<span class="cstat-no" title="statement not covered" >if(this._maxCols&gt;0&amp;&amp;this._maxRows&gt;0)<span class="cstat-no" title="statement not covered" >switch(this.cascade){case"left":case"right":<span class="cstat-no" title="statement not covered" >this._maxCols=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"up":case"down":default:<span class="cstat-no" title="statement not covered" >this._maxRows=0}<span class="cstat-no" title="statement not covered" ></span>f</span></span>or(var o=0,r=this._items;o&lt;r.length;o++){<span class="cstat-no" title="statement not covered" >var h=r[o],a=h.getGridPosition(),l=h.getSize();<span class="cstat-no" title="statement not covered" >i</span>f(this._removeFromGrid(h),this._maxCols&gt;0&amp;&amp;l.x&gt;this._maxCols?(l.x=this._maxCols,h.setSize(l)):this._maxRows&gt;0&amp;&amp;l.y&gt;this._maxRows&amp;&amp;(l.y=this._maxRows,h.setSize(l)),this._hasGridCollision(a,l)||!this._isWithinBounds(a,l)){<span class="cstat-no" title="statement not covered" >var g=this._fixGridPosition(a,l);<span class="cstat-no" title="statement not covered" >h</span>.setGridPosition(g)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._addToGrid(h)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._cascadeGrid()}<span class="cstat-no" title="statement not covered" ></span>t</span>his._calculateRowHeight(),this._calculateColWidth();<span class="cstat-no" title="statement not covered" >v</span>ar _=this._maxCols*this.colWidth,m=this._maxRows*this.rowHeight;<span class="cstat-no" title="statement not covered" >_</span>&gt;0&amp;&amp;this.minWidth&gt;_&amp;&amp;(this.minWidth=.75*this.colWidth),m&gt;0&amp;&amp;this.minHeight&gt;m&amp;&amp;(this.minHeight=.75*this.rowHeight),this.minWidth&gt;this.colWidth&amp;&amp;(this.minCols=Math.max(this.minCols,Math.ceil(this.minWidth/this.colWidth))),this.minHeight&gt;this.rowHeight&amp;&amp;(this.minRows=Math.max(this.minRows,Math.ceil(this.minHeight/this.rowHeight))),this._maxCols&gt;0&amp;&amp;this.minCols&gt;this._maxCols&amp;&amp;(this.minCols=1),this._maxRows&gt;0&amp;&amp;this.minRows&gt;this._maxRows&amp;&amp;(this.minRows=1),this._updateRatio();<span class="cstat-no" title="statement not covered" >f</span>or(var d=0,c=this._items;d&lt;c.length;d++){<span class="cstat-no" title="statement not covered" >var h=c[d];<span class="cstat-no" title="statement not covered" >t</span>his._removeFromGrid(h),h.setCascadeMode(this.cascade)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._updateLimit();<span class="cstat-no" title="statement not covered" >f</span>or(var u=0,p=this._items;u&lt;p.length;u++){<span class="cstat-no" title="statement not covered" >var h=p[u];<span class="cstat-no" title="statement not covered" >h</span>.recalculateSelf(),this._addToGrid(h)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._cascadeGrid(),this._updateSize()}</span>,t.prototype.getItemPosition=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return this._items[t].getGridPosition()}</span>,t.prototype.getItemSize=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return this._items[t].getSize()}</span>,t.prototype.ngDoCheck=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(null!=this._differ){<span class="cstat-no" title="statement not covered" >var t=this._differ.diff(this._config);<span class="cstat-no" title="statement not covered" >i</span>f(null!=t)<span class="cstat-no" title="statement not covered" >return this._applyChanges(t),!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>,t.prototype.setMargins=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this.marginTop=Math.max(parseInt(t[0]),0),this.marginRight=t.length&gt;=2?Math.max(parseInt(t[1]),0):this.marginTop,this.marginBottom=t.length&gt;=3?Math.max(parseInt(t[2]),0):this.marginTop,this.marginBottom=t.length&gt;=3?Math.max(parseInt(t[2]),0):this.marginTop,this.marginLeft=t.length&gt;=4?Math.max(parseInt(t[3]),0):this.marginRight}</span>,t.prototype.enableDrag=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.dragEnable=!0}</span>,t.prototype.disableDrag=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.dragEnable=!1}</span>,t.prototype.enableResize=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.resizeEnable=!0}</span>,t.prototype.disableResize=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.resizeEnable=!1}</span>,t.prototype.addItem=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(t.setCascadeMode(this.cascade),!this._preferNew){<span class="cstat-no" title="statement not covered" >var i=this._fixGridPosition(t.getGridPosition(),t.getSize());<span class="cstat-no" title="statement not covered" >t</span>.savePosition(i)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._items.push(t),this._addToGrid(t),t.recalculateSelf(),t.onCascadeEvent(),this._emitOnItemChange()}</span>,t.prototype.removeItem=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._removeFromGrid(t);<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;this._items.length;i++)<span class="cstat-no" title="statement not covered" >this._items[i]==t&amp;&amp;this._items.splice(i,1);<span class="cstat-no" title="statement not covered" >t</span></span>his._destroyed||(this._cascadeGrid(),this._updateSize(),this._items.forEach(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return t.recalculateSelf()}</span>),this._emitOnItemChange())}</span>,t.prototype.updateItem=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._removeFromGrid(t),this._addToGrid(t),this._cascadeGrid(),this._updateSize(),t.onCascadeEvent()}</span>,t.prototype.triggerCascade=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._cascadeGrid(null,null,!1)}</span>,t.prototype.resizeEventHandler=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._calculateColWidth(),this._calculateRowHeight(),this._updateRatio();<span class="cstat-no" title="statement not covered" >f</span>or(var i=0,e=this._items;i&lt;e.length;i++){<span class="cstat-no" title="statement not covered" >var s=e[i];<span class="cstat-no" title="statement not covered" >t</span>his._removeFromGrid(s)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._updateLimit();<span class="cstat-no" title="statement not covered" >f</span>or(var n=0,o=this._items;n&lt;o.length;n++){<span class="cstat-no" title="statement not covered" >var s=o[n];<span class="cstat-no" title="statement not covered" >t</span>his._addToGrid(s),s.recalculateSelf()}<span class="cstat-no" title="statement not covered" ></span>t</span>his._updateSize()}</span>,t.prototype.mouseDownEventHandler=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>var i=this._getMousePosition(t),e=this._getItemFromPosition(i);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=e&amp;&amp;(this.resizeEnable&amp;&amp;e.canResize(t)?this._resizeReady=!0:this.dragEnable&amp;&amp;e.canDrag(t)&amp;&amp;(this._dragReady=!0)),!0}</span>,t.prototype.mouseUpEventHandler=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return this.isDragging?(this._dragStop(t),!1):this.isResizing?(this._resizeStop(t),!1):((this._dragReady||this._resizeReady)&amp;&amp;(this._dragReady=!1,this._resizeReady=!1),!0)}</span>,t.prototype.mouseMoveEventHandler=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(this._resizeReady)<span class="cstat-no" title="statement not covered" >return void this._resizeStart(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(this._dragReady)<span class="cstat-no" title="statement not covered" >return void this._dragStart(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(this.isDragging)<span class="cstat-no" title="statement not covered" >this._drag(t);e</span>lse <span class="cstat-no" title="statement not covered" >if(this.isResizing)<span class="cstat-no" title="statement not covered" >this._resize(t);e</span>lse{<span class="cstat-no" title="statement not covered" >var i=this._getMousePosition(t),e=this._getItemFromPosition(i);<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;e.onMouseMove(t)}</span>}</span></span>,t.prototype._calculateColWidth=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this._autoResize&amp;&amp;(this._maxCols&gt;0||this._visibleCols&gt;0)){<span class="cstat-no" title="statement not covered" >var t=this._maxCols&gt;0?this._maxCols:this._visibleCols,i=this._ngEl.nativeElement.getBoundingClientRect().width,e=Math.floor(i/t);<span class="cstat-no" title="statement not covered" >e</span>-=this.marginLeft+this.marginRight,e&gt;0&amp;&amp;(this.colWidth=e),(this.colWidth&lt;this.minWidth||this.minCols&gt;this._config.min_cols)&amp;&amp;(this.minCols=Math.max(this._config.min_cols,Math.ceil(this.minWidth/this.colWidth)))}</span>}</span>,t.prototype._calculateRowHeight=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(this._autoResize&amp;&amp;(this._maxRows&gt;0||this._visibleRows&gt;0)){<span class="cstat-no" title="statement not covered" >var t=this._maxRows&gt;0?this._maxRows:this._visibleRows,i=window.innerHeight-this.marginTop-this.marginBottom,e=Math.max(Math.floor(i/t),this.minHeight);<span class="cstat-no" title="statement not covered" >e</span>-=this.marginTop+this.marginBottom,e&gt;0&amp;&amp;(this.rowHeight=e),(this.rowHeight&lt;this.minHeight||this.minRows&gt;this._config.min_rows)&amp;&amp;(this.minRows=Math.max(this._config.min_rows,Math.ceil(this.minHeight/this.rowHeight)))}</span>}</span>,t.prototype._updateRatio=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._autoResize&amp;&amp;this._maintainRatio&amp;&amp;(this._maxCols&gt;0&amp;&amp;this._visibleRows&lt;=0?this.rowHeight=this.colWidth/this._aspectRatio:this._maxRows&gt;0&amp;&amp;this._visibleCols&lt;=0?this.colWidth=this._aspectRatio*this.rowHeight:0==this._maxCols&amp;&amp;0==this._maxRows&amp;&amp;(this._visibleCols&gt;0?this.rowHeight=this.colWidth/this._aspectRatio:this._visibleRows&gt;0&amp;&amp;(this.colWidth=this._aspectRatio*this.rowHeight)))}</span>,t.prototype._updateLimit=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>!this._autoResize&amp;&amp;this._limitToScreen&amp;&amp;this._limitGrid(this._getContainerColumns())}</span>,t.prototype._applyChanges=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>var i=this;<span class="cstat-no" title="statement not covered" >t</span>.forEachAddedItem(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>i._config[t.key]=t.currentValue}</span>),t.forEachChangedItem(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>i._config[t.key]=t.currentValue}</span>),t.forEachRemovedItem(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>delete i._config[t.key]}</span>),this.setConfig(this._config)}</span>,t.prototype._resizeStart=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(this.resizeEnable){<span class="cstat-no" title="statement not covered" >var i=this._getMousePosition(t),e=this._getItemFromPosition(i);<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;(e.startMoving(),this._resizingItem=e,this._resizeDirection=e.canResize(t),this._removeFromGrid(e),this._createPlaceholder(e),this.isResizing=!0,this._resizeReady=!1,this.onResizeStart.emit(e),e.onResizeStartEvent())}</span>}</span>,t.prototype._dragStart=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(this.dragEnable){<span class="cstat-no" title="statement not covered" >var i=this._getMousePosition(t),e=this._getItemFromPosition(i);<span class="cstat-no" title="statement not covered" >i</span>f(e){<span class="cstat-no" title="statement not covered" >var s=e.getPosition(),n={left:i.left-s.left,top:i.top-s.top};<span class="cstat-no" title="statement not covered" >e</span>.startMoving(),this._draggingItem=e,this._posOffset=n,this._removeFromGrid(e),this._createPlaceholder(e),this.isDragging=!0,this._dragReady=!1,this.onDragStart.emit(e),e.onDragStartEvent(),this._zoomOnDrag&amp;&amp;this._zoomOut()}</span>}</span>}</span>,t.prototype._zoomOut=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._renderer.setElementStyle(this._ngEl.nativeElement,"transform","scale(0.5, 0.5)")}</span>,t.prototype._resetZoom=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._renderer.setElementStyle(this._ngEl.nativeElement,"transform","")}</span>,t.prototype._drag=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(this.isDragging){<span class="cstat-no" title="statement not covered" >window.getSelection?window.getSelection().empty?window.getSelection().empty():window.getSelection().removeAllRanges&amp;&amp;window.getSelection().removeAllRanges():document.selection&amp;&amp;document.selection.empty();<span class="cstat-no" title="statement not covered" >v</span>ar i=this._getMousePosition(t),e=i.left-this._posOffset.left,s=i.top-this._posOffset.top,n=this._draggingItem.getGridPosition(),o=this._calculateGridPosition(e,s),r=this._draggingItem.getSize();<span class="cstat-no" title="statement not covered" >t</span>his._isWithinBoundsX(o,r)||(o.col=this._maxCols-(r.x-1)),this._isWithinBoundsY(o,r)||(o.row=this._maxRows-(r.y-1)),!this._autoResize&amp;&amp;this._limitToScreen&amp;&amp;o.col+r.x-1&gt;this._getContainerColumns()&amp;&amp;(o.col=this._getContainerColumns()-(r.x-1)),o.col==n.col&amp;&amp;o.row==n.row||(this._draggingItem.setGridPosition(o,this._fixToGrid),this._placeholderRef.instance.setGridPosition(o),["up","down","left","right"].indexOf(this.cascade)&gt;=0&amp;&amp;(this._fixGridCollisions(o,r,!0),this._cascadeGrid(o,r))),this._fixToGrid||this._draggingItem.setPosition(e,s),this.onDrag.emit(this._draggingItem),this._draggingItem.onDragEvent()}</span>}</span>,t.prototype._resize=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(this.isResizing){<span class="cstat-no" title="statement not covered" >window.getSelection?window.getSelection().empty?window.getSelection().empty():window.getSelection().removeAllRanges&amp;&amp;window.getSelection().removeAllRanges():document.selection&amp;&amp;document.selection.empty();<span class="cstat-no" title="statement not covered" >v</span>ar i=this._getMousePosition(t),e=this._resizingItem.getPosition(),s=this._resizingItem.getDimensions(),n="height"==this._resizeDirection?s.width:i.left-e.left+10,o="width"==this._resizeDirection?s.height:i.top-e.top+10;<span class="cstat-no" title="statement not covered" >n</span>&lt;this.minWidth&amp;&amp;(n=this.minWidth),o&lt;this.minHeight&amp;&amp;(o=this.minHeight),n&lt;this._resizingItem.minWidth&amp;&amp;(n=this._resizingItem.minWidth),o&lt;this._resizingItem.minHeight&amp;&amp;(o=this._resizingItem.minHeight);<span class="cstat-no" title="statement not covered" >v</span>ar r=this._calculateGridSize(n,o),h=this._resizingItem.getSize(),a=this._resizingItem.getGridPosition();<span class="cstat-no" title="statement not covered" >t</span>his._isWithinBoundsX(a,r)||(r.x=this._maxCols-a.col+1),this._isWithinBoundsY(a,r)||(r.y=this._maxRows-a.row+1),r=this._resizingItem.fixResize(r),r.x==h.x&amp;&amp;r.y==h.y||(this._resizingItem.setSize(r,!1),this._placeholderRef.instance.setSize(r),["up","down","left","right"].indexOf(this.cascade)&gt;=0&amp;&amp;(this._fixGridCollisions(a,r,!0),this._cascadeGrid(a,r))),this._fixToGrid||this._resizingItem.setDimensions(n,o);<span class="cstat-no" title="statement not covered" >v</span>ar l=this._maxGridSize(e.left+n+2*t.movementX,e.top+o+2*t.movementY);<span class="cstat-no" title="statement not covered" >"</span>height"==this._resizeDirection&amp;&amp;(l.x=a.col+h.x),"width"==this._resizeDirection&amp;&amp;(l.y=a.row+h.y),this.onResize.emit(this._resizingItem),this._resizingItem.onResizeEvent()}</span>}</span>,t.prototype._dragStop=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(this.isDragging){<span class="cstat-no" title="statement not covered" >this.isDragging=!1;<span class="cstat-no" title="statement not covered" >v</span>ar i=this._draggingItem.getGridPosition();<span class="cstat-no" title="statement not covered" >t</span>his._draggingItem.savePosition(i),this._addToGrid(this._draggingItem),this._cascadeGrid(),this._draggingItem.stopMoving(),this._draggingItem.onDragStopEvent(),this.onDragStop.emit(this._draggingItem),this._draggingItem=null,this._posOffset=null,this._placeholderRef.destroy(),this._emitOnItemChange(),this._zoomOnDrag&amp;&amp;this._resetZoom()}</span>}</span>,t.prototype._resizeStop=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(this.isResizing){<span class="cstat-no" title="statement not covered" >this.isResizing=!1;<span class="cstat-no" title="statement not covered" >v</span>ar i=this._resizingItem.getSize();<span class="cstat-no" title="statement not covered" >t</span>his._resizingItem.setSize(i),this._addToGrid(this._resizingItem),this._cascadeGrid(),this._resizingItem.stopMoving(),this._resizingItem.onResizeStopEvent(),this.onResizeStop.emit(this._resizingItem),this._resizingItem=null,this._resizeDirection=null,this._placeholderRef.destroy(),this._emitOnItemChange()}</span>}</span>,t.prototype._maxGridSize=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>var e=Math.ceil(t/(this.colWidth+this.marginLeft+this.marginRight)),s=Math.ceil(i/(this.rowHeight+this.marginTop+this.marginBottom));<span class="cstat-no" title="statement not covered" >r</span>eturn{x:e,y:s}}</span>,t.prototype._calculateGridSize=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>t+=this.marginLeft+this.marginRight,i+=this.marginTop+this.marginBottom;<span class="cstat-no" title="statement not covered" >v</span>ar e=Math.max(this.minCols,Math.round(t/(this.colWidth+this.marginLeft+this.marginRight))),s=Math.max(this.minRows,Math.round(i/(this.rowHeight+this.marginTop+this.marginBottom)));<span class="cstat-no" title="statement not covered" >r</span>eturn this._isWithinBoundsX({col:1,row:1},{x:e,y:s})||(e=this._maxCols),this._isWithinBoundsY({col:1,row:1},{x:e,y:s})||(s=this._maxRows),{x:e,y:s}}</span>,t.prototype._calculateGridPosition=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>var e=Math.max(1,Math.round(t/(this.colWidth+this.marginLeft+this.marginRight))+1),s=Math.max(1,Math.round(i/(this.rowHeight+this.marginTop+this.marginBottom))+1);<span class="cstat-no" title="statement not covered" >r</span>eturn this._isWithinBoundsX({col:e,row:s},{x:1,y:1})||(e=this._maxCols),this._isWithinBoundsY({col:e,row:s},{x:1,y:1})||(s=this._maxRows),{col:e,row:s}}</span>,t.prototype._hasGridCollision=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>var e=this._getCollisions(t,i);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=e&amp;&amp;0!=e.length&amp;&amp;e.some(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return!(null===t)}</span>)}</span>,t.prototype._getCollisions=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>for(var e=[],s=0;s&lt;i.y;s++)<span class="cstat-no" title="statement not covered" >if(null!=this._itemGrid[t.row+s])<span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;i.x;n++)<span class="cstat-no" title="statement not covered" >if(null!=this._itemGrid[t.row+s][t.col+n]){<span class="cstat-no" title="statement not covered" >var o=this._itemGrid[t.row+s][t.col+n];<span class="cstat-no" title="statement not covered" >e</span>.indexOf(o)&lt;0&amp;&amp;e.push(o);<span class="cstat-no" title="statement not covered" >v</span>ar r=o.getGridPosition(),h=o.getSize();<span class="cstat-no" title="statement not covered" >n</span>=r.col+h.x-t.col}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn e}</span>,t.prototype._fixGridCollisions=<span class="fstat-no" title="function not covered" >function(t,i,e){<span class="cstat-no" title="statement not covered" ></span>for(void 0===e&amp;&amp;(e=!1);this._hasGridCollision(t,i);){<span class="cstat-no" title="statement not covered" >var s=this._getCollisions(t,i);<span class="cstat-no" title="statement not covered" >t</span>his._removeFromGrid(s[0]);<span class="cstat-no" title="statement not covered" >v</span>ar n=s[0].getGridPosition(),o=s[0].getSize();<span class="cstat-no" title="statement not covered" >s</span>witch(this.cascade){case"up":case"down":default:<span class="cstat-no" title="statement not covered" >var r=n.row;<span class="cstat-no" title="statement not covered" >n</span>.row=t.row+i.y,this._isWithinBoundsY(n,o)||(n.col=t.col+i.x,n.row=r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"left":case"right":<span class="cstat-no" title="statement not covered" >var h=n.col;<span class="cstat-no" title="statement not covered" >n</span>.col=t.col+i.x,this._isWithinBoundsX(n,o)||(n.col=h,n.row=t.row+i.y)}<span class="cstat-no" title="statement not covered" ></span>e</span>?s[0].savePosition(n):s[0].setGridPosition(n),this._fixGridCollisions(n,o,e),this._addToGrid(s[0]),s[0].onCascadeEvent()}</span>}</span>,t.prototype._limitGrid=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>var i=this._items.slice();<span class="cstat-no" title="statement not covered" >i</span>.sort(<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>var e=t.getSavedPosition(),s=i.getSavedPosition();<span class="cstat-no" title="statement not covered" >r</span>eturn e.row==s.row?e.col==s.col?0:e.col&lt;s.col?-1:1:e.row&lt;s.row?-1:1}</span>);<span class="cstat-no" title="statement not covered" >f</span>or(var e={},s={},n=1;n&lt;=t;n++)<span class="cstat-no" title="statement not covered" >e[n]=1,s[n]=1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=1;i.length&gt;0;){<span class="cstat-no" title="statement not covered" >for(var r=[],h={start:1,end:1,length:0},a=1;a&lt;=t;a++)<span class="cstat-no" title="statement not covered" >e[a]&lt;=o?(0==h.length&amp;&amp;(h.start=a),h.length++,h.end=a+1):h.length&gt;0&amp;&amp;(r.push(h),h={start:a,end:a,length:0});<span class="cstat-no" title="statement not covered" >h</span></span>.length&gt;0&amp;&amp;r.push(h);<span class="cstat-no" title="statement not covered" >f</span>or(var l=r.map(function(t){return t.length}),g=[];i.length&gt;0;){<span class="cstat-no" title="statement not covered" >var _=i[0];<span class="cstat-no" title="statement not covered" >i</span>f(_.row&gt;o)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >v</span></span>ar m=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var d in l){<span class="cstat-no" title="statement not covered" >if(_.sizex&lt;=l[d]){<span class="cstat-no" title="statement not covered" >l[d]-=_.sizex,m=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>_</span>.sizex&gt;l[d]&amp;&amp;(l[d]=0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!m)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >g</span></span>.push(i.shift())}<span class="cstat-no" title="statement not covered" ></span>i</span>f(g.length&gt;0){<span class="cstat-no" title="statement not covered" >for(var c=[],u=t,n=g.length-1;n&gt;=0;n--){<span class="cstat-no" title="statement not covered" >for(var p=1,f=r.length-1;f&gt;=0;f--)<span class="cstat-no" title="statement not covered" >if(!(r[f].start&gt;u||r[f].start&gt;t-g[n].sizex||r[f].length&lt;g[n].sizex||u&lt;r[f].end&amp;&amp;u-r[f].start&lt;g[n].sizex)){<span class="cstat-no" title="statement not covered" >p=(u&lt;r[f].end?u:r[f].end)-g[n].sizex;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>c</span></span>[n]=Math.min(p,g[n].row==o?g[n].col:1),u=c[n]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var y=1,v=0;g.length&gt;0;){<span class="cstat-no" title="statement not covered" >for(var _=g.shift(),f=0;f&lt;r.length;f++)<span class="cstat-no" title="statement not covered" >if(!(r[f].length&lt;_.sizex||y&gt;r[f].end||y&gt;r[f].start&amp;&amp;r[f].end-y&lt;_.sizex)){<span class="cstat-no" title="statement not covered" >y&lt;r[f].start&amp;&amp;(y=r[f].start);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>_</span></span>.setGridPosition({col:Math.max(y,c[v]),row:o}),y=_.currentCol+_.sizex,v++;<span class="cstat-no" title="statement not covered" >f</span>or(var n=_.currentCol;n&lt;_.currentCol+_.sizex;n++)<span class="cstat-no" title="statement not covered" >e[n]=_.currentRow+_.sizey}</span></span>}</span>else <span class="cstat-no" title="statement not covered" >if(0===g.length&amp;&amp;1===r.length&amp;&amp;r[0].length&gt;=t){<span class="cstat-no" title="statement not covered" >var _=i.shift();<span class="cstat-no" title="statement not covered" >_</span>.setGridPosition({col:1,row:o});<span class="cstat-no" title="statement not covered" >f</span>or(var n=_.currentCol;n&lt;_.currentCol+_.sizex;n++)<span class="cstat-no" title="statement not covered" >e[n]=_.currentRow+_.sizey}<span class="cstat-no" title="statement not covered" ></span></span>v</span></span>ar E=0;<span class="cstat-no" title="statement not covered" >f</span>or(var d in e)<span class="cstat-no" title="statement not covered" >e[d]&gt;o&amp;&amp;(0==E||e[d]&lt;E)&amp;&amp;(E=e[d]);<span class="cstat-no" title="statement not covered" >o</span></span>=E&lt;=o?o+1:E}</span>}</span>,t.prototype._cascadeGrid=<span class="fstat-no" title="function not covered" >function(t,i,e){<span class="cstat-no" title="statement not covered" ></span>if(void 0===e&amp;&amp;(e=!0),!this._destroyed){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;!i)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot cascade with only position and not dimensions");<span class="cstat-no" title="statement not covered" >s</span></span>witch(this.isDragging&amp;&amp;this._draggingItem&amp;&amp;!t&amp;&amp;!i?(t=this._draggingItem.getGridPosition(),i=this._draggingItem.getSize()):this.isResizing&amp;&amp;this._resizingItem&amp;&amp;!t&amp;&amp;!i&amp;&amp;(t=this._resizingItem.getGridPosition(),i=this._resizingItem.getSize()),this.cascade){case"up":case"down":<span class="cstat-no" title="statement not covered" >for(var s=[0],n=1;n&lt;=this._curMaxCol;n++)<span class="cstat-no" title="statement not covered" >s[n]=1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=1;o&lt;=this._curMaxRow;o++)<span class="cstat-no" title="statement not covered" >if(void 0!=this._itemGrid[o])<span class="cstat-no" title="statement not covered" >for(var r=1;r&lt;=this._curMaxCol&amp;&amp;void 0!=this._itemGrid[o];r++)<span class="cstat-no" title="statement not covered" >if(!(o&lt;s[r])&amp;&amp;null!=this._itemGrid[o][r]){<span class="cstat-no" title="statement not covered" >var h=this._itemGrid[o][r];<span class="cstat-no" title="statement not covered" >i</span>f(h.isFixed)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >v</span></span>ar a=h.getSize(),l=h.getGridPosition();<span class="cstat-no" title="statement not covered" >i</span>f(l.col!=r||l.row!=o)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>or(var g=s[r],n=1;n&lt;a.x;n++)<span class="cstat-no" title="statement not covered" >g=Math.max(s[r+n],g);<span class="cstat-no" title="statement not covered" >t</span></span>&amp;&amp;r+a.x&gt;t.col&amp;&amp;r&lt;t.col+i.x&amp;&amp;(o&gt;=t.row&amp;&amp;o&lt;t.row+i.y||a.y&gt;t.row-g&amp;&amp;o&gt;=t.row+i.y&amp;&amp;g&lt;t.row+i.y)&amp;&amp;(g=Math.max(g,t.row+i.y));<span class="cstat-no" title="statement not covered" >v</span>ar _={col:r,row:g};<span class="cstat-no" title="statement not covered" >g</span>!=l.row&amp;&amp;this._isWithinBoundsY(_,a)&amp;&amp;(this._removeFromGrid(h),e?h.savePosition(_):h.setGridPosition(_),h.onCascadeEvent(),this._addToGrid(h));<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;a.x;n++)<span class="cstat-no" title="statement not covered" >s[r+n]=g+a.y}<span class="cstat-no" title="statement not covered" ></span></span>b</span></span></span></span>reak;c</span>ase"left":case"right":<span class="cstat-no" title="statement not covered" >for(var m=[0],n=1;n&lt;=this._curMaxRow;n++)<span class="cstat-no" title="statement not covered" >m[n]=1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=1;o&lt;=this._curMaxRow;o++)<span class="cstat-no" title="statement not covered" >if(void 0!=this._itemGrid[o])<span class="cstat-no" title="statement not covered" >for(var r=1;r&lt;=this._curMaxCol&amp;&amp;void 0!=this._itemGrid[o];r++)<span class="cstat-no" title="statement not covered" >if(!(r&lt;m[o])&amp;&amp;null!=this._itemGrid[o][r]){<span class="cstat-no" title="statement not covered" >var h=this._itemGrid[o][r],a=h.getSize(),l=h.getGridPosition();<span class="cstat-no" title="statement not covered" >i</span>f(l.col!=r||l.row!=o)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>or(var g=m[o],n=1;n&lt;a.y;n++)<span class="cstat-no" title="statement not covered" >g=Math.max(m[o+n],g);<span class="cstat-no" title="statement not covered" >t</span></span>&amp;&amp;o+a.y&gt;t.row&amp;&amp;o&lt;t.row+i.y&amp;&amp;(r&gt;=t.col&amp;&amp;r&lt;t.col+i.x||a.x&gt;t.col-g&amp;&amp;r&gt;=t.col+i.x&amp;&amp;g&lt;t.col+i.x)&amp;&amp;(g=Math.max(g,t.col+i.x));<span class="cstat-no" title="statement not covered" >v</span>ar _={col:g,row:o};<span class="cstat-no" title="statement not covered" >g</span>!=l.col&amp;&amp;this._isWithinBoundsX(_,a)&amp;&amp;(this._removeFromGrid(h),e?h.savePosition(_):h.setGridPosition(_),h.onCascadeEvent(),this._addToGrid(h));<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;a.y;n++)<span class="cstat-no" title="statement not covered" >m[o+n]=g+a.x}</span></span>}</span></span></span></span>}</span>}</span>,t.prototype._fixGridPosition=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>for(;this._hasGridCollision(t,i)||!this._isWithinBounds(t,i);){<span class="cstat-no" title="statement not covered" >if(this._hasGridCollision(t,i))<span class="cstat-no" title="statement not covered" >switch(this.cascade){case"up":case"down":default:<span class="cstat-no" title="statement not covered" >t.row++;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"left":case"right":<span class="cstat-no" title="statement not covered" >t.col++}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his._isWithinBoundsY(t,i)||(t.col++,t.row=1),this._isWithinBoundsX(t,i)||(t.row++,t.col=1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,t.prototype._isWithinBoundsX=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>return this._limitToScreen?t.col+i.x-1&lt;=this._getContainerColumns():0==this._maxCols||t.col+i.x-1&lt;=this._maxCols}</span>,t.prototype._isWithinBoundsY=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>return 0==this._maxRows||t.row+i.y-1&lt;=this._maxRows}</span>,t.prototype._isWithinBounds=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>return this._isWithinBoundsX(t,i)&amp;&amp;this._isWithinBoundsY(t,i)}</span>,t.prototype._addToGrid=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>var i=t.getGridPosition(),e=t.getSize();<span class="cstat-no" title="statement not covered" >t</span>his._hasGridCollision(i,e)&amp;&amp;(this._fixGridCollisions(i,e),i=t.getGridPosition());<span class="cstat-no" title="statement not covered" >f</span>or(var s=0;s&lt;e.y;s++){<span class="cstat-no" title="statement not covered" >null==this._itemGrid[i.row+s]&amp;&amp;(this._itemGrid[i.row+s]={});<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;e.x;n++)<span class="cstat-no" title="statement not covered" >this._itemGrid[i.row+s][i.col+n]=t,this._updateSize(i.col+e.x-1,i.row+e.y-1)}</span></span>}</span>,t.prototype._removeFromGrid=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>for(var i in this._itemGrid)<span class="cstat-no" title="statement not covered" >for(var e in this._itemGrid[i])<span class="cstat-no" title="statement not covered" >this._itemGrid[i][e]==t&amp;&amp;delete this._itemGrid[i][e]}</span></span></span>,t.prototype._updateSize=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>if(!this._destroyed){<span class="cstat-no" title="statement not covered" >t=void 0==t?this._getMaxCol():t,i=void 0==i?this._getMaxRow():i;<span class="cstat-no" title="statement not covered" >v</span>ar e=Math.max(this._curMaxCol,t),s=Math.max(this._curMaxRow,i);<span class="cstat-no" title="statement not covered" >e</span>==this._curMaxCol&amp;&amp;s==this._curMaxRow||(this._curMaxCol=e,this._curMaxRow=s),this._renderer.setElementStyle(this._ngEl.nativeElement,"width","100%"),this._renderer.setElementStyle(this._ngEl.nativeElement,"height",this._getMaxRow()*(this.rowHeight+this.marginTop+this.marginBottom)+"px")}</span>}</span>,t.prototype._getMaxRow=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return Math.max.apply(null,this._items.map(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return t.getGridPosition().row+t.getSize().y-1}</span>))}</span>,t.prototype._getMaxCol=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return Math.max.apply(null,this._items.map(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return t.getGridPosition().col+t.getSize().x-1}</span>))}</span>,t.prototype._getMousePosition=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>(window.TouchEvent&amp;&amp;t instanceof TouchEvent||t.touches||t.changedTouches)&amp;&amp;(t=t.touches.length&gt;0?t.touches[0]:t.changedTouches[0]);<span class="cstat-no" title="statement not covered" >v</span>ar i=this._ngEl.nativeElement.getBoundingClientRect(),e=t.clientX-i.left,s=t.clientY-i.top;<span class="cstat-no" title="statement not covered" >r</span>eturn"down"==this.cascade&amp;&amp;(s=i.top+i.height-t.clientY),"right"==this.cascade&amp;&amp;(e=i.left+i.width-t.clientX),this.isDragging&amp;&amp;this._zoomOnDrag&amp;&amp;(e*=2,s*=2),{left:e,top:s}}</span>,t.prototype._getAbsoluteMousePosition=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return(window.TouchEvent&amp;&amp;t instanceof TouchEvent||t.touches||t.changedTouches)&amp;&amp;(t=t.touches.length&gt;0?t.touches[0]:t.changedTouches[0]),{left:t.clientX,top:t.clientY}}</span>,t.prototype._getContainerColumns=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=this._ngEl.nativeElement.getBoundingClientRect().width;<span class="cstat-no" title="statement not covered" >r</span>eturn Math.floor(t/(this.colWidth+this.marginLeft+this.marginRight))}</span>,t.prototype._getItemFromPosition=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>for(var i=0,e=this._items;i&lt;e.length;i++){<span class="cstat-no" title="statement not covered" >var s=e[i],n=s.getDimensions(),o=s.getPosition();<span class="cstat-no" title="statement not covered" >i</span>f(t.left&gt;o.left+this.marginLeft&amp;&amp;t.left&lt;o.left+this.marginLeft+n.width&amp;&amp;t.top&gt;o.top+this.marginTop&amp;&amp;t.top&lt;o.top+this.marginTop+n.height)<span class="cstat-no" title="statement not covered" >return s}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>,t.prototype._createPlaceholder=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>var i=t.getGridPosition(),s=t.getSize(),n=this.componentFactoryResolver.resolveComponentFactory(e),o=t.containerRef.createComponent(n);<span class="cstat-no" title="statement not covered" >t</span>his._placeholderRef=o;<span class="cstat-no" title="statement not covered" >v</span>ar r=o.instance;<span class="cstat-no" title="statement not covered" >r</span>.registerGrid(this),r.setCascadeMode(this.cascade),r.setGridPosition({col:i.col,row:i.row}),r.setSize({x:s.x,y:s.y})}</span>,t.prototype._emitOnItemChange=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this.onItemChange.emit(this._items.map(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return t.getEventOutput()}</span>))}</span>,t.CONST_DEFAULT_CONFIG={margins:[10],draggable:!0,resizable:!0,max_cols:0,max_rows:0,visible_cols:0,visible_rows:0,col_width:250,row_height:250,cascade:"up",min_width:100,min_height:100,fix_to_grid:!1,auto_style:!0,auto_resize:!1,maintain_ratio:!1,prefer_new:!1,zoom_on_drag:!1},t.decorators=[{type:i.Directive,args:[{selector:"[ngGrid]",inputs:["config: ngGrid"],host:{"(mousedown)":"mouseDownEventHandler($event)","(mousemove)":"mouseMoveEventHandler($event)","(mouseup)":"mouseUpEventHandler($event)","(touchstart)":"mouseDownEventHandler($event)","(touchmove)":"mouseMoveEventHandler($event)","(touchend)":"mouseUpEventHandler($event)","(window:resize)":"resizeEventHandler($event)","(document:mousemove)":"mouseMoveEventHandler($event)","(document:mouseup)":"mouseUpEventHandler($event)"}}]}],t.ctorParameters=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return[{type:i.KeyValueDiffers},{type:i.ElementRef},{type:i.Renderer},{type:i.ComponentFactoryResolver},{type:i.ViewContainerRef}]}</span>,t.propDecorators={onDragStart:[{type:i.Output}],onDrag:[{type:i.Output}],onDragStop:[{type:i.Output}],onResizeStart:[{type:i.Output}],onResize:[{type:i.Output}],onResizeStop:[{type:i.Output}],onItemChange:[{type:i.Output}]},t}(),n=function(){<span class="fstat-no" title="function not covered" >function t(e,s,n,o,r){<span class="cstat-no" title="statement not covered" ></span>this._differs=e,this._ngEl=s,this._renderer=n,this._ngGrid=o,this.containerRef=r,this.onItemChange=new i.EventEmitter(!1),this.onDragStart=new i.EventEmitter,this.onDrag=new i.EventEmitter,this.onDragStop=new i.EventEmitter,this.onDragAny=new i.EventEmitter,this.onResizeStart=new i.EventEmitter,this.onResize=new i.EventEmitter,this.onResizeStop=new i.EventEmitter,this.onResizeAny=new i.EventEmitter,this.onChangeStart=new i.EventEmitter,this.onChange=new i.EventEmitter,this.onChangeStop=new i.EventEmitter,this.onChangeAny=new i.EventEmitter,this.ngGridItemChange=new i.EventEmitter,this.isFixed=!1,this.isDraggable=!0,this.isResizable=!0,this.minWidth=0,this.minHeight=0,this._position={col:1,row:1},this._currentPosition={col:1,row:1},this._size={x:1,y:1},this._config=t.CONST_DEFAULT_CONFIG,this._added=!1,this._maxCols=0,this._minCols=0,this._maxRows=0,this._minRows=0}</span>return Object.defineProperty(t.prototype,"config",{set:<span class="fstat-no" title="function not covered" >function(i){<span class="cstat-no" title="statement not covered" ></span>var e=t.CONST_DEFAULT_CONFIG;<span class="cstat-no" title="statement not covered" >f</span>or(var s in e)<span class="cstat-no" title="statement not covered" >null==i[s]&amp;&amp;(i[s]=e[s]);<span class="cstat-no" title="statement not covered" >t</span></span>his.setConfig(i),null==this._differ&amp;&amp;null!=i&amp;&amp;(this._differ=this._differs.find(this._config).create(null)),this._added||(this._added=!0,this._ngGrid.addItem(this)),this._recalculateDimensions(),this._recalculatePosition()}</span>,enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"sizex",{get:function(){return this._size.x},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"sizey",{get:function(){return this._size.y},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"col",{get:function(){return this._position.col},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"row",{get:function(){return this._position.row},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"currentCol",{get:function(){return this._currentPosition.col},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"currentRow",{get:function(){return this._currentPosition.row},enumerable:!0,configurable:!0}),t.prototype.onResizeStartEvent=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=this.getEventOutput();<span class="cstat-no" title="statement not covered" >t</span>his.onResizeStart.emit(t),this.onResizeAny.emit(t),this.onChangeStart.emit(t),this.onChangeAny.emit(t)}</span>,t.prototype.onResizeEvent=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=this.getEventOutput();<span class="cstat-no" title="statement not covered" >t</span>his.onResize.emit(t),this.onResizeAny.emit(t),this.onChange.emit(t),this.onChangeAny.emit(t)}</span>,t.prototype.onResizeStopEvent=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=this.getEventOutput();<span class="cstat-no" title="statement not covered" >t</span>his.onResizeStop.emit(t),this.onResizeAny.emit(t),this.onChangeStop.emit(t),this.onChangeAny.emit(t),this._config.sizex=this._size.x,this._config.sizey=this._size.y,this.ngGridItemChange.emit(this._config)}</span>,t.prototype.onDragStartEvent=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=this.getEventOutput();<span class="cstat-no" title="statement not covered" >t</span>his.onDragStart.emit(t),this.onDragAny.emit(t),this.onChangeStart.emit(t),this.onChangeAny.emit(t)}</span>,t.prototype.onDragEvent=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=this.getEventOutput();<span class="cstat-no" title="statement not covered" >t</span>his.onDrag.emit(t),this.onDragAny.emit(t),this.onChange.emit(t),this.onChangeAny.emit(t)}</span>,t.prototype.onDragStopEvent=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=this.getEventOutput();<span class="cstat-no" title="statement not covered" >t</span>his.onDragStop.emit(t),this.onDragAny.emit(t),this.onChangeStop.emit(t),this.onChangeAny.emit(t),this._config.col=this._position.col,this._config.row=this._position.row,this.ngGridItemChange.emit(this._config)}</span>,t.prototype.onCascadeEvent=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._config.sizex=this._size.x,this._config.sizey=this._size.y,this._config.col=this._position.col,this._config.row=this._position.row,this.ngGridItemChange.emit(this._config)}</span>,t.prototype.ngOnInit=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._renderer.setElementClass(this._ngEl.nativeElement,"grid-item",!0),this._ngGrid.autoStyle&amp;&amp;this._renderer.setElementStyle(this._ngEl.nativeElement,"position","absolute"),this._recalculateDimensions(),this._recalculatePosition(),this._added||(this._added=!0,this._ngGrid.addItem(this))}</span>,t.prototype.canDrag=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>return!!this.isDraggable&amp;&amp;(!this._dragHandle||this.findHandle(this._dragHandle,t.target))}</span>,t.prototype.findHandle=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>for(var e=i;e&amp;&amp;e!=this._ngEl.nativeElement;){<span class="cstat-no" title="statement not covered" >if(this.elementMatches(e,t))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >e</span></span>=e.parentElement}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>,t.prototype.canResize=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(!this.isResizable)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._resizeHandle)<span class="cstat-no" title="statement not covered" >return this.findHandle(this._resizeHandle,t.target)?"both":null;<span class="cstat-no" title="statement not covered" >v</span></span>ar i=this._getMousePosition(t);<span class="cstat-no" title="statement not covered" >r</span>eturn i.left&lt;this._elemWidth&amp;&amp;i.left&gt;this._elemWidth-this._borderSize&amp;&amp;i.top&lt;this._elemHeight&amp;&amp;i.top&gt;this._elemHeight-this._borderSize?"both":i.left&lt;this._elemWidth&amp;&amp;i.left&gt;this._elemWidth-this._borderSize?"width":i.top&lt;this._elemHeight&amp;&amp;i.top&gt;this._elemHeight-this._borderSize?"height":null}</span>,t.prototype.onMouseMove=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(this._ngGrid.autoStyle)<span class="cstat-no" title="statement not covered" >if(this._ngGrid.resizeEnable&amp;&amp;!this._resizeHandle&amp;&amp;this.isResizable){<span class="cstat-no" title="statement not covered" >var i=this._getMousePosition(t);<span class="cstat-no" title="statement not covered" >i</span>.left&lt;this._elemWidth&amp;&amp;i.left&gt;this._elemWidth-this._borderSize&amp;&amp;i.top&lt;this._elemHeight&amp;&amp;i.top&gt;this._elemHeight-this._borderSize?this._renderer.setElementStyle(this._ngEl.nativeElement,"cursor","nwse-resize"):i.left&lt;this._elemWidth&amp;&amp;i.left&gt;this._elemWidth-this._borderSize?this._renderer.setElementStyle(this._ngEl.nativeElement,"cursor","ew-resize"):i.top&lt;this._elemHeight&amp;&amp;i.top&gt;this._elemHeight-this._borderSize?this._renderer.setElementStyle(this._ngEl.nativeElement,"cursor","ns-resize"):this._ngGrid.dragEnable&amp;&amp;this.canDrag(t)?this._renderer.setElementStyle(this._ngEl.nativeElement,"cursor","move"):this._renderer.setElementStyle(this._ngEl.nativeElement,"cursor","default")}</span>else <span class="cstat-no" title="statement not covered" >this._ngGrid.resizeEnable&amp;&amp;this.canResize(t)?this._renderer.setElementStyle(this._ngEl.nativeElement,"cursor","nwse-resize"):this._ngGrid.dragEnable&amp;&amp;this.canDrag(t)?this._renderer.setElementStyle(this._ngEl.nativeElement,"cursor","move"):this._renderer.setElementStyle(this._ngEl.nativeElement,"cursor","default");</span></span></span>
},t.prototype.ngOnDestroy=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._added&amp;&amp;this._ngGrid.removeItem(this)}</span>,t.prototype.getElement=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this._ngEl}</span>,t.prototype.getDragHandle=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this._dragHandle}</span>,t.prototype.getResizeHandle=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this._resizeHandle}</span>,t.prototype.getDimensions=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return{width:this._elemWidth,height:this._elemHeight}}</span>,t.prototype.getSize=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this._size}</span>,t.prototype.getPosition=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return{left:this._elemLeft,top:this._elemTop}}</span>,t.prototype.getGridPosition=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this._currentPosition}</span>,t.prototype.getSavedPosition=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return this._position}</span>,t.prototype.setConfig=<span class="fstat-no" title="function not covered" >function(i){<span class="cstat-no" title="statement not covered" ></span>this._config=i,this._payload=i.payload,this._position.col=this._currentPosition.col=i.col?i.col:t.CONST_DEFAULT_CONFIG.col,this._position.row=this._currentPosition.row=i.row?i.row:t.CONST_DEFAULT_CONFIG.row,this._size.x=i.sizex?i.sizex:t.CONST_DEFAULT_CONFIG.sizex,this._size.y=i.sizey?i.sizey:t.CONST_DEFAULT_CONFIG.sizey,this._dragHandle=i.dragHandle,this._resizeHandle=i.resizeHandle,this._borderSize=i.borderSize,this.isDraggable=!!i.draggable,this.isResizable=!!i.resizable,this.isFixed=!!i.fixed,this._maxCols=!isNaN(i.maxCols)&amp;&amp;isFinite(i.maxCols)?i.maxCols:0,this._minCols=!isNaN(i.minCols)&amp;&amp;isFinite(i.minCols)?i.minCols:0,this._maxRows=!isNaN(i.maxRows)&amp;&amp;isFinite(i.maxRows)?i.maxRows:0,this._minRows=!isNaN(i.minRows)&amp;&amp;isFinite(i.minRows)?i.minRows:0,this.minWidth=!isNaN(i.minWidth)&amp;&amp;isFinite(i.minWidth)?i.minWidth:0,this.minHeight=!isNaN(i.minHeight)&amp;&amp;isFinite(i.minHeight)?i.minHeight:0,this._minCols&gt;0&amp;&amp;this._maxCols&gt;0&amp;&amp;this._minCols&gt;this._maxCols&amp;&amp;(this._minCols=0),this._minRows&gt;0&amp;&amp;this._maxRows&gt;0&amp;&amp;this._minRows&gt;this._maxRows&amp;&amp;(this._minRows=0),this._added&amp;&amp;this._ngGrid.updateItem(this),this._size=this.fixResize(this._size),this._recalculatePosition(),this._recalculateDimensions()}</span>,t.prototype.ngDoCheck=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(null!=this._differ){<span class="cstat-no" title="statement not covered" >var t=this._differ.diff(this._config);<span class="cstat-no" title="statement not covered" >i</span>f(null!=t)<span class="cstat-no" title="statement not covered" >return this._applyChanges(t),!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>,t.prototype.setSize=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>void 0===i&amp;&amp;(i=!0),t=this.fixResize(t),this._size=t,i&amp;&amp;this._recalculateDimensions(),this.onItemChange.emit(this.getEventOutput())}</span>,t.prototype.setGridPosition=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>void 0===i&amp;&amp;(i=!0),this._currentPosition=t,i&amp;&amp;this._recalculatePosition(),this.onItemChange.emit(this.getEventOutput())}</span>,t.prototype.savePosition=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._position=t,this._currentPosition=t,this._recalculatePosition(),this.onItemChange.emit(this.getEventOutput())}</span>,t.prototype.getEventOutput=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return{payload:this._payload,col:this._currentPosition.col,row:this._currentPosition.row,sizex:this._size.x,sizey:this._size.y,width:this._elemWidth,height:this._elemHeight,left:this._elemLeft,top:this._elemTop}}</span>,t.prototype.setPosition=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>switch(this._cascadeMode){case"up":case"left":default:<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"transform","translate("+t+"px, "+i+"px)");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"transform","translate("+-t+"px, "+i+"px)");<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"down":<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"transform","translate("+t+"px, "+-i+"px)")}<span class="cstat-no" title="statement not covered" ></span>t</span>his._elemLeft=t,this._elemTop=i}</span>,t.prototype.setCascadeMode=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>switch(this._cascadeMode=t,t){case"up":case"left":default:<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"left","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"top","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"right",null),this._renderer.setElementStyle(this._ngEl.nativeElement,"bottom",null);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"right","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"top","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"left",null),this._renderer.setElementStyle(this._ngEl.nativeElement,"bottom",null);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"down":<span class="cstat-no" title="statement not covered" >this._renderer.setElementStyle(this._ngEl.nativeElement,"left","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"bottom","0px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"right",null),this._renderer.setElementStyle(this._ngEl.nativeElement,"top",null)}</span>}</span>,t.prototype.setDimensions=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>t&lt;this.minWidth&amp;&amp;(t=this.minWidth),i&lt;this.minHeight&amp;&amp;(i=this.minHeight),this._renderer.setElementStyle(this._ngEl.nativeElement,"width",t+"px"),this._renderer.setElementStyle(this._ngEl.nativeElement,"height",i+"px"),this._elemWidth=t,this._elemHeight=i}</span>,t.prototype.startMoving=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._renderer.setElementClass(this._ngEl.nativeElement,"moving",!0);<span class="cstat-no" title="statement not covered" >v</span>ar t=window.getComputedStyle(this._ngEl.nativeElement);<span class="cstat-no" title="statement not covered" >t</span>his._ngGrid.autoStyle&amp;&amp;this._renderer.setElementStyle(this._ngEl.nativeElement,"z-index",(parseInt(t.getPropertyValue("z-index"))+1).toString())}</span>,t.prototype.stopMoving=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._renderer.setElementClass(this._ngEl.nativeElement,"moving",!1);<span class="cstat-no" title="statement not covered" >v</span>ar t=window.getComputedStyle(this._ngEl.nativeElement);<span class="cstat-no" title="statement not covered" >t</span>his._ngGrid.autoStyle&amp;&amp;this._renderer.setElementStyle(this._ngEl.nativeElement,"z-index",(parseInt(t.getPropertyValue("z-index"))-1).toString())}</span>,t.prototype.recalculateSelf=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._recalculatePosition(),this._recalculateDimensions()}</span>,t.prototype.fixResize=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>this._maxCols&gt;0&amp;&amp;t.x&gt;this._maxCols&amp;&amp;(t.x=this._maxCols),this._maxRows&gt;0&amp;&amp;t.y&gt;this._maxRows&amp;&amp;(t.y=this._maxRows),this._minCols&gt;0&amp;&amp;t.x&lt;this._minCols&amp;&amp;(t.x=this._minCols),this._minRows&gt;0&amp;&amp;t.y&lt;this._minRows&amp;&amp;(t.y=this._minRows);<span class="cstat-no" title="statement not covered" >v</span>ar i=t.x*this._ngGrid.colWidth+(this._ngGrid.marginLeft+this._ngGrid.marginRight)*(t.x-1);<span class="cstat-no" title="statement not covered" >i</span>&lt;this.minWidth&amp;&amp;(t.x=Math.ceil((this.minWidth+this._ngGrid.marginRight+this._ngGrid.marginLeft)/(this._ngGrid.colWidth+this._ngGrid.marginRight+this._ngGrid.marginLeft)));<span class="cstat-no" title="statement not covered" >v</span>ar e=t.y*this._ngGrid.rowHeight+(this._ngGrid.marginTop+this._ngGrid.marginBottom)*(t.y-1);<span class="cstat-no" title="statement not covered" >r</span>eturn e&lt;this.minHeight&amp;&amp;(t.y=Math.ceil((this.minHeight+this._ngGrid.marginBottom+this._ngGrid.marginTop)/(this._ngGrid.rowHeight+this._ngGrid.marginBottom+this._ngGrid.marginTop))),t}</span>,t.prototype.elementMatches=<span class="fstat-no" title="function not covered" >function(t,i){<span class="cstat-no" title="statement not covered" ></span>if(t.matches)<span class="cstat-no" title="statement not covered" >return t.matches(i);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.oMatchesSelector)<span class="cstat-no" title="statement not covered" >return t.oMatchesSelector(i);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.msMatchesSelector)<span class="cstat-no" title="statement not covered" >return t.msMatchesSelector(i);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.mozMatchesSelector)<span class="cstat-no" title="statement not covered" >return t.mozMatchesSelector(i);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.webkitMatchesSelector)<span class="cstat-no" title="statement not covered" >return t.webkitMatchesSelector(i);<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=(t.document||t.ownerDocument).querySelectorAll(i),s=e.length;--s&gt;=0&amp;&amp;e.item(s)!==t;);<span class="cstat-no" title="statement not covered" >r</span>eturn s&gt;-1}</span>,t.prototype._recalculatePosition=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var t=(this._ngGrid.colWidth+this._ngGrid.marginLeft+this._ngGrid.marginRight)*(this._currentPosition.col-1)+this._ngGrid.marginLeft,i=(this._ngGrid.rowHeight+this._ngGrid.marginTop+this._ngGrid.marginBottom)*(this._currentPosition.row-1)+this._ngGrid.marginTop;<span class="cstat-no" title="statement not covered" >t</span>his.setPosition(t,i)}</span>,t.prototype._recalculateDimensions=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>this._size.x&lt;this._ngGrid.minCols&amp;&amp;(this._size.x=this._ngGrid.minCols),this._size.y&lt;this._ngGrid.minRows&amp;&amp;(this._size.y=this._ngGrid.minRows);<span class="cstat-no" title="statement not covered" >v</span>ar t=this._ngGrid.colWidth*this._size.x+(this._ngGrid.marginLeft+this._ngGrid.marginRight)*(this._size.x-1),i=this._ngGrid.rowHeight*this._size.y+(this._ngGrid.marginTop+this._ngGrid.marginBottom)*(this._size.y-1),e=Math.max(this.minWidth,this._ngGrid.minWidth,t),s=Math.max(this.minHeight,this._ngGrid.minHeight,i);<span class="cstat-no" title="statement not covered" >t</span>his.setDimensions(e,s)}</span>,t.prototype._getMousePosition=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>if(t.originalEvent&amp;&amp;t.originalEvent.touches){<span class="cstat-no" title="statement not covered" >var i=t.originalEvent;<span class="cstat-no" title="statement not covered" >t</span>=i.touches.length?i.touches[0]:i.changedTouches.length?i.changedTouches[0]:t}</span>else <span class="cstat-no" title="statement not covered" >t.touches&amp;&amp;(t=t.touches.length?t.touches[0]:t.changedTouches.length?t.changedTouches[0]:t);<span class="cstat-no" title="statement not covered" >v</span></span>ar e=this._ngEl.nativeElement.getBoundingClientRect();<span class="cstat-no" title="statement not covered" >r</span>eturn{left:t.clientX-e.left,top:t.clientY-e.top}}</span>,t.prototype._applyChanges=<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>var i=this;<span class="cstat-no" title="statement not covered" >t</span>.forEachAddedItem(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>i._config[t.key]=t.currentValue}</span>),t.forEachChangedItem(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>i._config[t.key]=t.currentValue}</span>),t.forEachRemovedItem(<span class="fstat-no" title="function not covered" >function(t){<span class="cstat-no" title="statement not covered" ></span>delete i._config[t.key]}</span>),this.setConfig(this._config)}</span>,t.CONST_DEFAULT_CONFIG={col:1,row:1,sizex:1,sizey:1,dragHandle:null,resizeHandle:null,fixed:!1,draggable:!0,resizable:!0,borderSize:25},t.decorators=[{type:i.Directive,args:[{selector:"[ngGridItem]",inputs:["config: ngGridItem"]}]}],t.ctorParameters=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return[{type:i.KeyValueDiffers},{type:i.ElementRef},{type:i.Renderer},{type:s},{type:i.ViewContainerRef}]}</span>,t.propDecorators={onItemChange:[{type:i.Output}],onDragStart:[{type:i.Output}],onDrag:[{type:i.Output}],onDragStop:[{type:i.Output}],onDragAny:[{type:i.Output}],onResizeStart:[{type:i.Output}],onResize:[{type:i.Output}],onResizeStop:[{type:i.Output}],onResizeAny:[{type:i.Output}],onChangeStart:[{type:i.Output}],onChange:[{type:i.Output}],onChangeStop:[{type:i.Output}],onChangeAny:[{type:i.Output}],ngGridItemChange:[{type:i.Output}]},t}(),o=function(){<span class="fstat-no" title="function not covered" >function t(){</span>}return t.decorators=[{type:i.NgModule,args:[{declarations:[s,n,e],entryComponents:[e],exports:[s,n]}]}],t.ctorParameters=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return[]}</span>,t}();t.NgGrid=s,t.NgGridItem=n,t.NgGridPlaceholder=e,t.NgGridModule=o,Object.defineProperty(t,"__esModule",{value:!0})});
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Wed Apr 19 2017 02:49:28 GMT+0000 (UTC)</div>
</div>
</body>
</html>
