{"/home/travis/build/npmtest/node-npmtest-angular2-grid/test.js":"/* istanbul instrument in package npmtest_angular2_grid */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-angular2-grid/lib.npmtest_angular2_grid.js":"/* istanbul instrument in package npmtest_angular2_grid */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_angular2_grid = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_angular2_grid = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-angular2-grid/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-angular2-grid && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_angular2_grid */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_angular2_grid\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_angular2_grid.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_angular2_grid.rollup.js'] =\n            local.assetsDict['/assets.npmtest_angular2_grid.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_angular2_grid.__dirname + '/lib.npmtest_angular2_grid.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-angular2-grid/node_modules/angular2-grid/bundles/NgGrid.umd.min.js":"!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?i(exports,require(\"@angular/core\")):\"function\"==typeof define&&define.amd?define([\"exports\",\"@angular/core\"],i):i((t.ng=t.ng||{},t.ng.grid=t.ng.grid||{}),t.ng.core)}(this,function(t,i){\"use strict\";var e=function(){function t(t,i){this._ngEl=t,this._renderer=i}return t.prototype.registerGrid=function(t){this._ngGrid=t},t.prototype.ngOnInit=function(){this._renderer.setElementClass(this._ngEl.nativeElement,\"grid-placeholder\",!0),this._ngGrid.autoStyle&&this._renderer.setElementStyle(this._ngEl.nativeElement,\"position\",\"absolute\")},t.prototype.setSize=function(t){this._size=t,this._recalculateDimensions()},t.prototype.setGridPosition=function(t){this._position=t,this._recalculatePosition()},t.prototype.setCascadeMode=function(t){switch(this._cascadeMode=t,t){case\"up\":case\"left\":default:this._renderer.setElementStyle(this._ngEl.nativeElement,\"left\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"top\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"right\",null),this._renderer.setElementStyle(this._ngEl.nativeElement,\"bottom\",null);break;case\"right\":this._renderer.setElementStyle(this._ngEl.nativeElement,\"right\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"top\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"left\",null),this._renderer.setElementStyle(this._ngEl.nativeElement,\"bottom\",null);break;case\"down\":this._renderer.setElementStyle(this._ngEl.nativeElement,\"left\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"bottom\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"right\",null),this._renderer.setElementStyle(this._ngEl.nativeElement,\"top\",null)}},t.prototype._setDimensions=function(t,i){this._renderer.setElementStyle(this._ngEl.nativeElement,\"width\",t+\"px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"height\",i+\"px\")},t.prototype._setPosition=function(t,i){switch(this._cascadeMode){case\"up\":case\"left\":default:this._renderer.setElementStyle(this._ngEl.nativeElement,\"transform\",\"translate(\"+t+\"px, \"+i+\"px)\");break;case\"right\":this._renderer.setElementStyle(this._ngEl.nativeElement,\"transform\",\"translate(\"+-t+\"px, \"+i+\"px)\");break;case\"down\":this._renderer.setElementStyle(this._ngEl.nativeElement,\"transform\",\"translate(\"+t+\"px, \"+-i+\"px)\")}},t.prototype._recalculatePosition=function(){var t=(this._ngGrid.colWidth+this._ngGrid.marginLeft+this._ngGrid.marginRight)*(this._position.col-1)+this._ngGrid.marginLeft,i=(this._ngGrid.rowHeight+this._ngGrid.marginTop+this._ngGrid.marginBottom)*(this._position.row-1)+this._ngGrid.marginTop;this._setPosition(t,i)},t.prototype._recalculateDimensions=function(){var t=this._ngGrid.colWidth*this._size.x+(this._ngGrid.marginLeft+this._ngGrid.marginRight)*(this._size.x-1),i=this._ngGrid.rowHeight*this._size.y+(this._ngGrid.marginTop+this._ngGrid.marginBottom)*(this._size.y-1);this._setDimensions(t,i)},t.decorators=[{type:i.Component,args:[{selector:\"ng-grid-placeholder\",template:\"\"}]}],t.ctorParameters=function(){return[{type:i.ElementRef},{type:i.Renderer}]},t}(),s=function(){function t(e,s,n,o,r){this._differs=e,this._ngEl=s,this._renderer=n,this.componentFactoryResolver=o,this._containerRef=r,this.onDragStart=new i.EventEmitter,this.onDrag=new i.EventEmitter,this.onDragStop=new i.EventEmitter,this.onResizeStart=new i.EventEmitter,this.onResize=new i.EventEmitter,this.onResizeStop=new i.EventEmitter,this.onItemChange=new i.EventEmitter,this.colWidth=250,this.rowHeight=250,this.minCols=1,this.minRows=1,this.marginTop=10,this.marginRight=10,this.marginBottom=10,this.marginLeft=10,this.isDragging=!1,this.isResizing=!1,this.autoStyle=!0,this.resizeEnable=!0,this.dragEnable=!0,this.cascade=\"up\",this.minWidth=100,this.minHeight=100,this._items=[],this._draggingItem=null,this._resizingItem=null,this._resizeDirection=null,this._itemGrid={},this._maxCols=0,this._maxRows=0,this._visibleCols=0,this._visibleRows=0,this._setWidth=250,this._setHeight=250,this._posOffset=null,this._adding=!1,this._placeholderRef=null,this._fixToGrid=!1,this._autoResize=!1,this._destroyed=!1,this._maintainRatio=!1,this._preferNew=!1,this._zoomOnDrag=!1,this._limitToScreen=!1,this._curMaxRow=0,this._curMaxCol=0,this._dragReady=!1,this._resizeReady=!1,this._config=t.CONST_DEFAULT_CONFIG}return Object.defineProperty(t.prototype,\"config\",{set:function(t){this.setConfig(t),null==this._differ&&null!=t&&(this._differ=this._differs.find(this._config).create(null))},enumerable:!0,configurable:!0}),t.prototype.ngOnInit=function(){this._renderer.setElementClass(this._ngEl.nativeElement,\"grid\",!0),this.autoStyle&&this._renderer.setElementStyle(this._ngEl.nativeElement,\"position\",\"relative\"),this.setConfig(this._config)},t.prototype.ngOnDestroy=function(){this._destroyed=!0},t.prototype.setConfig=function(t){this._config=t;var i=!1;for(var e in t){var s=t[e],n=s?parseInt(s):0;switch(e){case\"margins\":this.setMargins(s);break;case\"col_width\":this.colWidth=Math.max(n,1);break;case\"row_height\":this.rowHeight=Math.max(n,1);break;case\"auto_style\":this.autoStyle=!!s;break;case\"auto_resize\":this._autoResize=!!s;break;case\"draggable\":this.dragEnable=!!s;break;case\"resizable\":this.resizeEnable=!!s;break;case\"max_rows\":i=i||this._maxRows!=n,this._maxRows=n<0?0:n;break;case\"max_cols\":i=i||this._maxCols!=n,this._maxCols=n<0?0:n;break;case\"visible_rows\":this._visibleRows=Math.max(n,0);break;case\"visible_cols\":this._visibleCols=Math.max(n,0);break;case\"min_rows\":this.minRows=Math.max(n,1);break;case\"min_cols\":this.minCols=Math.max(n,1);break;case\"min_height\":this.minHeight=Math.max(n,1);break;case\"min_width\":this.minWidth=Math.max(n,1);break;case\"zoom_on_drag\":this._zoomOnDrag=!!s;break;case\"cascade\":this.cascade!=s&&(this.cascade=s,this._cascadeGrid());break;case\"fix_to_grid\":this._fixToGrid=!!s;break;case\"maintain_ratio\":this._maintainRatio=!!s;break;case\"prefer_new\":this._preferNew=!!s;break;case\"limit_to_screen\":this._limitToScreen=!!s}}if(this._maintainRatio&&(this.colWidth&&this.rowHeight?this._aspectRatio=this.colWidth/this.rowHeight:this._maintainRatio=!1),i){if(this._maxCols>0&&this._maxRows>0)switch(this.cascade){case\"left\":case\"right\":this._maxCols=0;break;case\"up\":case\"down\":default:this._maxRows=0}for(var o=0,r=this._items;o<r.length;o++){var h=r[o],a=h.getGridPosition(),l=h.getSize();if(this._removeFromGrid(h),this._maxCols>0&&l.x>this._maxCols?(l.x=this._maxCols,h.setSize(l)):this._maxRows>0&&l.y>this._maxRows&&(l.y=this._maxRows,h.setSize(l)),this._hasGridCollision(a,l)||!this._isWithinBounds(a,l)){var g=this._fixGridPosition(a,l);h.setGridPosition(g)}this._addToGrid(h)}this._cascadeGrid()}this._calculateRowHeight(),this._calculateColWidth();var _=this._maxCols*this.colWidth,m=this._maxRows*this.rowHeight;_>0&&this.minWidth>_&&(this.minWidth=.75*this.colWidth),m>0&&this.minHeight>m&&(this.minHeight=.75*this.rowHeight),this.minWidth>this.colWidth&&(this.minCols=Math.max(this.minCols,Math.ceil(this.minWidth/this.colWidth))),this.minHeight>this.rowHeight&&(this.minRows=Math.max(this.minRows,Math.ceil(this.minHeight/this.rowHeight))),this._maxCols>0&&this.minCols>this._maxCols&&(this.minCols=1),this._maxRows>0&&this.minRows>this._maxRows&&(this.minRows=1),this._updateRatio();for(var d=0,c=this._items;d<c.length;d++){var h=c[d];this._removeFromGrid(h),h.setCascadeMode(this.cascade)}this._updateLimit();for(var u=0,p=this._items;u<p.length;u++){var h=p[u];h.recalculateSelf(),this._addToGrid(h)}this._cascadeGrid(),this._updateSize()},t.prototype.getItemPosition=function(t){return this._items[t].getGridPosition()},t.prototype.getItemSize=function(t){return this._items[t].getSize()},t.prototype.ngDoCheck=function(){if(null!=this._differ){var t=this._differ.diff(this._config);if(null!=t)return this._applyChanges(t),!0}return!1},t.prototype.setMargins=function(t){this.marginTop=Math.max(parseInt(t[0]),0),this.marginRight=t.length>=2?Math.max(parseInt(t[1]),0):this.marginTop,this.marginBottom=t.length>=3?Math.max(parseInt(t[2]),0):this.marginTop,this.marginBottom=t.length>=3?Math.max(parseInt(t[2]),0):this.marginTop,this.marginLeft=t.length>=4?Math.max(parseInt(t[3]),0):this.marginRight},t.prototype.enableDrag=function(){this.dragEnable=!0},t.prototype.disableDrag=function(){this.dragEnable=!1},t.prototype.enableResize=function(){this.resizeEnable=!0},t.prototype.disableResize=function(){this.resizeEnable=!1},t.prototype.addItem=function(t){if(t.setCascadeMode(this.cascade),!this._preferNew){var i=this._fixGridPosition(t.getGridPosition(),t.getSize());t.savePosition(i)}this._items.push(t),this._addToGrid(t),t.recalculateSelf(),t.onCascadeEvent(),this._emitOnItemChange()},t.prototype.removeItem=function(t){this._removeFromGrid(t);for(var i=0;i<this._items.length;i++)this._items[i]==t&&this._items.splice(i,1);this._destroyed||(this._cascadeGrid(),this._updateSize(),this._items.forEach(function(t){return t.recalculateSelf()}),this._emitOnItemChange())},t.prototype.updateItem=function(t){this._removeFromGrid(t),this._addToGrid(t),this._cascadeGrid(),this._updateSize(),t.onCascadeEvent()},t.prototype.triggerCascade=function(){this._cascadeGrid(null,null,!1)},t.prototype.resizeEventHandler=function(t){this._calculateColWidth(),this._calculateRowHeight(),this._updateRatio();for(var i=0,e=this._items;i<e.length;i++){var s=e[i];this._removeFromGrid(s)}this._updateLimit();for(var n=0,o=this._items;n<o.length;n++){var s=o[n];this._addToGrid(s),s.recalculateSelf()}this._updateSize()},t.prototype.mouseDownEventHandler=function(t){var i=this._getMousePosition(t),e=this._getItemFromPosition(i);return null!=e&&(this.resizeEnable&&e.canResize(t)?this._resizeReady=!0:this.dragEnable&&e.canDrag(t)&&(this._dragReady=!0)),!0},t.prototype.mouseUpEventHandler=function(t){return this.isDragging?(this._dragStop(t),!1):this.isResizing?(this._resizeStop(t),!1):((this._dragReady||this._resizeReady)&&(this._dragReady=!1,this._resizeReady=!1),!0)},t.prototype.mouseMoveEventHandler=function(t){if(this._resizeReady)return void this._resizeStart(t);if(this._dragReady)return void this._dragStart(t);if(this.isDragging)this._drag(t);else if(this.isResizing)this._resize(t);else{var i=this._getMousePosition(t),e=this._getItemFromPosition(i);e&&e.onMouseMove(t)}},t.prototype._calculateColWidth=function(){if(this._autoResize&&(this._maxCols>0||this._visibleCols>0)){var t=this._maxCols>0?this._maxCols:this._visibleCols,i=this._ngEl.nativeElement.getBoundingClientRect().width,e=Math.floor(i/t);e-=this.marginLeft+this.marginRight,e>0&&(this.colWidth=e),(this.colWidth<this.minWidth||this.minCols>this._config.min_cols)&&(this.minCols=Math.max(this._config.min_cols,Math.ceil(this.minWidth/this.colWidth)))}},t.prototype._calculateRowHeight=function(){if(this._autoResize&&(this._maxRows>0||this._visibleRows>0)){var t=this._maxRows>0?this._maxRows:this._visibleRows,i=window.innerHeight-this.marginTop-this.marginBottom,e=Math.max(Math.floor(i/t),this.minHeight);e-=this.marginTop+this.marginBottom,e>0&&(this.rowHeight=e),(this.rowHeight<this.minHeight||this.minRows>this._config.min_rows)&&(this.minRows=Math.max(this._config.min_rows,Math.ceil(this.minHeight/this.rowHeight)))}},t.prototype._updateRatio=function(){this._autoResize&&this._maintainRatio&&(this._maxCols>0&&this._visibleRows<=0?this.rowHeight=this.colWidth/this._aspectRatio:this._maxRows>0&&this._visibleCols<=0?this.colWidth=this._aspectRatio*this.rowHeight:0==this._maxCols&&0==this._maxRows&&(this._visibleCols>0?this.rowHeight=this.colWidth/this._aspectRatio:this._visibleRows>0&&(this.colWidth=this._aspectRatio*this.rowHeight)))},t.prototype._updateLimit=function(){!this._autoResize&&this._limitToScreen&&this._limitGrid(this._getContainerColumns())},t.prototype._applyChanges=function(t){var i=this;t.forEachAddedItem(function(t){i._config[t.key]=t.currentValue}),t.forEachChangedItem(function(t){i._config[t.key]=t.currentValue}),t.forEachRemovedItem(function(t){delete i._config[t.key]}),this.setConfig(this._config)},t.prototype._resizeStart=function(t){if(this.resizeEnable){var i=this._getMousePosition(t),e=this._getItemFromPosition(i);e&&(e.startMoving(),this._resizingItem=e,this._resizeDirection=e.canResize(t),this._removeFromGrid(e),this._createPlaceholder(e),this.isResizing=!0,this._resizeReady=!1,this.onResizeStart.emit(e),e.onResizeStartEvent())}},t.prototype._dragStart=function(t){if(this.dragEnable){var i=this._getMousePosition(t),e=this._getItemFromPosition(i);if(e){var s=e.getPosition(),n={left:i.left-s.left,top:i.top-s.top};e.startMoving(),this._draggingItem=e,this._posOffset=n,this._removeFromGrid(e),this._createPlaceholder(e),this.isDragging=!0,this._dragReady=!1,this.onDragStart.emit(e),e.onDragStartEvent(),this._zoomOnDrag&&this._zoomOut()}}},t.prototype._zoomOut=function(){this._renderer.setElementStyle(this._ngEl.nativeElement,\"transform\",\"scale(0.5, 0.5)\")},t.prototype._resetZoom=function(){this._renderer.setElementStyle(this._ngEl.nativeElement,\"transform\",\"\")},t.prototype._drag=function(t){if(this.isDragging){window.getSelection?window.getSelection().empty?window.getSelection().empty():window.getSelection().removeAllRanges&&window.getSelection().removeAllRanges():document.selection&&document.selection.empty();var i=this._getMousePosition(t),e=i.left-this._posOffset.left,s=i.top-this._posOffset.top,n=this._draggingItem.getGridPosition(),o=this._calculateGridPosition(e,s),r=this._draggingItem.getSize();this._isWithinBoundsX(o,r)||(o.col=this._maxCols-(r.x-1)),this._isWithinBoundsY(o,r)||(o.row=this._maxRows-(r.y-1)),!this._autoResize&&this._limitToScreen&&o.col+r.x-1>this._getContainerColumns()&&(o.col=this._getContainerColumns()-(r.x-1)),o.col==n.col&&o.row==n.row||(this._draggingItem.setGridPosition(o,this._fixToGrid),this._placeholderRef.instance.setGridPosition(o),[\"up\",\"down\",\"left\",\"right\"].indexOf(this.cascade)>=0&&(this._fixGridCollisions(o,r,!0),this._cascadeGrid(o,r))),this._fixToGrid||this._draggingItem.setPosition(e,s),this.onDrag.emit(this._draggingItem),this._draggingItem.onDragEvent()}},t.prototype._resize=function(t){if(this.isResizing){window.getSelection?window.getSelection().empty?window.getSelection().empty():window.getSelection().removeAllRanges&&window.getSelection().removeAllRanges():document.selection&&document.selection.empty();var i=this._getMousePosition(t),e=this._resizingItem.getPosition(),s=this._resizingItem.getDimensions(),n=\"height\"==this._resizeDirection?s.width:i.left-e.left+10,o=\"width\"==this._resizeDirection?s.height:i.top-e.top+10;n<this.minWidth&&(n=this.minWidth),o<this.minHeight&&(o=this.minHeight),n<this._resizingItem.minWidth&&(n=this._resizingItem.minWidth),o<this._resizingItem.minHeight&&(o=this._resizingItem.minHeight);var r=this._calculateGridSize(n,o),h=this._resizingItem.getSize(),a=this._resizingItem.getGridPosition();this._isWithinBoundsX(a,r)||(r.x=this._maxCols-a.col+1),this._isWithinBoundsY(a,r)||(r.y=this._maxRows-a.row+1),r=this._resizingItem.fixResize(r),r.x==h.x&&r.y==h.y||(this._resizingItem.setSize(r,!1),this._placeholderRef.instance.setSize(r),[\"up\",\"down\",\"left\",\"right\"].indexOf(this.cascade)>=0&&(this._fixGridCollisions(a,r,!0),this._cascadeGrid(a,r))),this._fixToGrid||this._resizingItem.setDimensions(n,o);var l=this._maxGridSize(e.left+n+2*t.movementX,e.top+o+2*t.movementY);\"height\"==this._resizeDirection&&(l.x=a.col+h.x),\"width\"==this._resizeDirection&&(l.y=a.row+h.y),this.onResize.emit(this._resizingItem),this._resizingItem.onResizeEvent()}},t.prototype._dragStop=function(t){if(this.isDragging){this.isDragging=!1;var i=this._draggingItem.getGridPosition();this._draggingItem.savePosition(i),this._addToGrid(this._draggingItem),this._cascadeGrid(),this._draggingItem.stopMoving(),this._draggingItem.onDragStopEvent(),this.onDragStop.emit(this._draggingItem),this._draggingItem=null,this._posOffset=null,this._placeholderRef.destroy(),this._emitOnItemChange(),this._zoomOnDrag&&this._resetZoom()}},t.prototype._resizeStop=function(t){if(this.isResizing){this.isResizing=!1;var i=this._resizingItem.getSize();this._resizingItem.setSize(i),this._addToGrid(this._resizingItem),this._cascadeGrid(),this._resizingItem.stopMoving(),this._resizingItem.onResizeStopEvent(),this.onResizeStop.emit(this._resizingItem),this._resizingItem=null,this._resizeDirection=null,this._placeholderRef.destroy(),this._emitOnItemChange()}},t.prototype._maxGridSize=function(t,i){var e=Math.ceil(t/(this.colWidth+this.marginLeft+this.marginRight)),s=Math.ceil(i/(this.rowHeight+this.marginTop+this.marginBottom));return{x:e,y:s}},t.prototype._calculateGridSize=function(t,i){t+=this.marginLeft+this.marginRight,i+=this.marginTop+this.marginBottom;var e=Math.max(this.minCols,Math.round(t/(this.colWidth+this.marginLeft+this.marginRight))),s=Math.max(this.minRows,Math.round(i/(this.rowHeight+this.marginTop+this.marginBottom)));return this._isWithinBoundsX({col:1,row:1},{x:e,y:s})||(e=this._maxCols),this._isWithinBoundsY({col:1,row:1},{x:e,y:s})||(s=this._maxRows),{x:e,y:s}},t.prototype._calculateGridPosition=function(t,i){var e=Math.max(1,Math.round(t/(this.colWidth+this.marginLeft+this.marginRight))+1),s=Math.max(1,Math.round(i/(this.rowHeight+this.marginTop+this.marginBottom))+1);return this._isWithinBoundsX({col:e,row:s},{x:1,y:1})||(e=this._maxCols),this._isWithinBoundsY({col:e,row:s},{x:1,y:1})||(s=this._maxRows),{col:e,row:s}},t.prototype._hasGridCollision=function(t,i){var e=this._getCollisions(t,i);return null!=e&&0!=e.length&&e.some(function(t){return!(null===t)})},t.prototype._getCollisions=function(t,i){for(var e=[],s=0;s<i.y;s++)if(null!=this._itemGrid[t.row+s])for(var n=0;n<i.x;n++)if(null!=this._itemGrid[t.row+s][t.col+n]){var o=this._itemGrid[t.row+s][t.col+n];e.indexOf(o)<0&&e.push(o);var r=o.getGridPosition(),h=o.getSize();n=r.col+h.x-t.col}return e},t.prototype._fixGridCollisions=function(t,i,e){for(void 0===e&&(e=!1);this._hasGridCollision(t,i);){var s=this._getCollisions(t,i);this._removeFromGrid(s[0]);var n=s[0].getGridPosition(),o=s[0].getSize();switch(this.cascade){case\"up\":case\"down\":default:var r=n.row;n.row=t.row+i.y,this._isWithinBoundsY(n,o)||(n.col=t.col+i.x,n.row=r);break;case\"left\":case\"right\":var h=n.col;n.col=t.col+i.x,this._isWithinBoundsX(n,o)||(n.col=h,n.row=t.row+i.y)}e?s[0].savePosition(n):s[0].setGridPosition(n),this._fixGridCollisions(n,o,e),this._addToGrid(s[0]),s[0].onCascadeEvent()}},t.prototype._limitGrid=function(t){var i=this._items.slice();i.sort(function(t,i){var e=t.getSavedPosition(),s=i.getSavedPosition();return e.row==s.row?e.col==s.col?0:e.col<s.col?-1:1:e.row<s.row?-1:1});for(var e={},s={},n=1;n<=t;n++)e[n]=1,s[n]=1;for(var o=1;i.length>0;){for(var r=[],h={start:1,end:1,length:0},a=1;a<=t;a++)e[a]<=o?(0==h.length&&(h.start=a),h.length++,h.end=a+1):h.length>0&&(r.push(h),h={start:a,end:a,length:0});h.length>0&&r.push(h);for(var l=r.map(function(t){return t.length}),g=[];i.length>0;){var _=i[0];if(_.row>o)break;var m=!1;for(var d in l){if(_.sizex<=l[d]){l[d]-=_.sizex,m=!0;break}_.sizex>l[d]&&(l[d]=0)}if(!m)break;g.push(i.shift())}if(g.length>0){for(var c=[],u=t,n=g.length-1;n>=0;n--){for(var p=1,f=r.length-1;f>=0;f--)if(!(r[f].start>u||r[f].start>t-g[n].sizex||r[f].length<g[n].sizex||u<r[f].end&&u-r[f].start<g[n].sizex)){p=(u<r[f].end?u:r[f].end)-g[n].sizex;break}c[n]=Math.min(p,g[n].row==o?g[n].col:1),u=c[n]}for(var y=1,v=0;g.length>0;){for(var _=g.shift(),f=0;f<r.length;f++)if(!(r[f].length<_.sizex||y>r[f].end||y>r[f].start&&r[f].end-y<_.sizex)){y<r[f].start&&(y=r[f].start);break}_.setGridPosition({col:Math.max(y,c[v]),row:o}),y=_.currentCol+_.sizex,v++;for(var n=_.currentCol;n<_.currentCol+_.sizex;n++)e[n]=_.currentRow+_.sizey}}else if(0===g.length&&1===r.length&&r[0].length>=t){var _=i.shift();_.setGridPosition({col:1,row:o});for(var n=_.currentCol;n<_.currentCol+_.sizex;n++)e[n]=_.currentRow+_.sizey}var E=0;for(var d in e)e[d]>o&&(0==E||e[d]<E)&&(E=e[d]);o=E<=o?o+1:E}},t.prototype._cascadeGrid=function(t,i,e){if(void 0===e&&(e=!0),!this._destroyed){if(t&&!i)throw new Error(\"Cannot cascade with only position and not dimensions\");switch(this.isDragging&&this._draggingItem&&!t&&!i?(t=this._draggingItem.getGridPosition(),i=this._draggingItem.getSize()):this.isResizing&&this._resizingItem&&!t&&!i&&(t=this._resizingItem.getGridPosition(),i=this._resizingItem.getSize()),this.cascade){case\"up\":case\"down\":for(var s=[0],n=1;n<=this._curMaxCol;n++)s[n]=1;for(var o=1;o<=this._curMaxRow;o++)if(void 0!=this._itemGrid[o])for(var r=1;r<=this._curMaxCol&&void 0!=this._itemGrid[o];r++)if(!(o<s[r])&&null!=this._itemGrid[o][r]){var h=this._itemGrid[o][r];if(h.isFixed)continue;var a=h.getSize(),l=h.getGridPosition();if(l.col!=r||l.row!=o)continue;for(var g=s[r],n=1;n<a.x;n++)g=Math.max(s[r+n],g);t&&r+a.x>t.col&&r<t.col+i.x&&(o>=t.row&&o<t.row+i.y||a.y>t.row-g&&o>=t.row+i.y&&g<t.row+i.y)&&(g=Math.max(g,t.row+i.y));var _={col:r,row:g};g!=l.row&&this._isWithinBoundsY(_,a)&&(this._removeFromGrid(h),e?h.savePosition(_):h.setGridPosition(_),h.onCascadeEvent(),this._addToGrid(h));for(var n=0;n<a.x;n++)s[r+n]=g+a.y}break;case\"left\":case\"right\":for(var m=[0],n=1;n<=this._curMaxRow;n++)m[n]=1;for(var o=1;o<=this._curMaxRow;o++)if(void 0!=this._itemGrid[o])for(var r=1;r<=this._curMaxCol&&void 0!=this._itemGrid[o];r++)if(!(r<m[o])&&null!=this._itemGrid[o][r]){var h=this._itemGrid[o][r],a=h.getSize(),l=h.getGridPosition();if(l.col!=r||l.row!=o)continue;for(var g=m[o],n=1;n<a.y;n++)g=Math.max(m[o+n],g);t&&o+a.y>t.row&&o<t.row+i.y&&(r>=t.col&&r<t.col+i.x||a.x>t.col-g&&r>=t.col+i.x&&g<t.col+i.x)&&(g=Math.max(g,t.col+i.x));var _={col:g,row:o};g!=l.col&&this._isWithinBoundsX(_,a)&&(this._removeFromGrid(h),e?h.savePosition(_):h.setGridPosition(_),h.onCascadeEvent(),this._addToGrid(h));for(var n=0;n<a.y;n++)m[o+n]=g+a.x}}}},t.prototype._fixGridPosition=function(t,i){for(;this._hasGridCollision(t,i)||!this._isWithinBounds(t,i);){if(this._hasGridCollision(t,i))switch(this.cascade){case\"up\":case\"down\":default:t.row++;break;case\"left\":case\"right\":t.col++}this._isWithinBoundsY(t,i)||(t.col++,t.row=1),this._isWithinBoundsX(t,i)||(t.row++,t.col=1)}return t},t.prototype._isWithinBoundsX=function(t,i){return this._limitToScreen?t.col+i.x-1<=this._getContainerColumns():0==this._maxCols||t.col+i.x-1<=this._maxCols},t.prototype._isWithinBoundsY=function(t,i){return 0==this._maxRows||t.row+i.y-1<=this._maxRows},t.prototype._isWithinBounds=function(t,i){return this._isWithinBoundsX(t,i)&&this._isWithinBoundsY(t,i)},t.prototype._addToGrid=function(t){var i=t.getGridPosition(),e=t.getSize();this._hasGridCollision(i,e)&&(this._fixGridCollisions(i,e),i=t.getGridPosition());for(var s=0;s<e.y;s++){null==this._itemGrid[i.row+s]&&(this._itemGrid[i.row+s]={});for(var n=0;n<e.x;n++)this._itemGrid[i.row+s][i.col+n]=t,this._updateSize(i.col+e.x-1,i.row+e.y-1)}},t.prototype._removeFromGrid=function(t){for(var i in this._itemGrid)for(var e in this._itemGrid[i])this._itemGrid[i][e]==t&&delete this._itemGrid[i][e]},t.prototype._updateSize=function(t,i){if(!this._destroyed){t=void 0==t?this._getMaxCol():t,i=void 0==i?this._getMaxRow():i;var e=Math.max(this._curMaxCol,t),s=Math.max(this._curMaxRow,i);e==this._curMaxCol&&s==this._curMaxRow||(this._curMaxCol=e,this._curMaxRow=s),this._renderer.setElementStyle(this._ngEl.nativeElement,\"width\",\"100%\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"height\",this._getMaxRow()*(this.rowHeight+this.marginTop+this.marginBottom)+\"px\")}},t.prototype._getMaxRow=function(){return Math.max.apply(null,this._items.map(function(t){return t.getGridPosition().row+t.getSize().y-1}))},t.prototype._getMaxCol=function(){return Math.max.apply(null,this._items.map(function(t){return t.getGridPosition().col+t.getSize().x-1}))},t.prototype._getMousePosition=function(t){(window.TouchEvent&&t instanceof TouchEvent||t.touches||t.changedTouches)&&(t=t.touches.length>0?t.touches[0]:t.changedTouches[0]);var i=this._ngEl.nativeElement.getBoundingClientRect(),e=t.clientX-i.left,s=t.clientY-i.top;return\"down\"==this.cascade&&(s=i.top+i.height-t.clientY),\"right\"==this.cascade&&(e=i.left+i.width-t.clientX),this.isDragging&&this._zoomOnDrag&&(e*=2,s*=2),{left:e,top:s}},t.prototype._getAbsoluteMousePosition=function(t){return(window.TouchEvent&&t instanceof TouchEvent||t.touches||t.changedTouches)&&(t=t.touches.length>0?t.touches[0]:t.changedTouches[0]),{left:t.clientX,top:t.clientY}},t.prototype._getContainerColumns=function(){var t=this._ngEl.nativeElement.getBoundingClientRect().width;return Math.floor(t/(this.colWidth+this.marginLeft+this.marginRight))},t.prototype._getItemFromPosition=function(t){for(var i=0,e=this._items;i<e.length;i++){var s=e[i],n=s.getDimensions(),o=s.getPosition();if(t.left>o.left+this.marginLeft&&t.left<o.left+this.marginLeft+n.width&&t.top>o.top+this.marginTop&&t.top<o.top+this.marginTop+n.height)return s}return null},t.prototype._createPlaceholder=function(t){var i=t.getGridPosition(),s=t.getSize(),n=this.componentFactoryResolver.resolveComponentFactory(e),o=t.containerRef.createComponent(n);this._placeholderRef=o;var r=o.instance;r.registerGrid(this),r.setCascadeMode(this.cascade),r.setGridPosition({col:i.col,row:i.row}),r.setSize({x:s.x,y:s.y})},t.prototype._emitOnItemChange=function(){this.onItemChange.emit(this._items.map(function(t){return t.getEventOutput()}))},t.CONST_DEFAULT_CONFIG={margins:[10],draggable:!0,resizable:!0,max_cols:0,max_rows:0,visible_cols:0,visible_rows:0,col_width:250,row_height:250,cascade:\"up\",min_width:100,min_height:100,fix_to_grid:!1,auto_style:!0,auto_resize:!1,maintain_ratio:!1,prefer_new:!1,zoom_on_drag:!1},t.decorators=[{type:i.Directive,args:[{selector:\"[ngGrid]\",inputs:[\"config: ngGrid\"],host:{\"(mousedown)\":\"mouseDownEventHandler($event)\",\"(mousemove)\":\"mouseMoveEventHandler($event)\",\"(mouseup)\":\"mouseUpEventHandler($event)\",\"(touchstart)\":\"mouseDownEventHandler($event)\",\"(touchmove)\":\"mouseMoveEventHandler($event)\",\"(touchend)\":\"mouseUpEventHandler($event)\",\"(window:resize)\":\"resizeEventHandler($event)\",\"(document:mousemove)\":\"mouseMoveEventHandler($event)\",\"(document:mouseup)\":\"mouseUpEventHandler($event)\"}}]}],t.ctorParameters=function(){return[{type:i.KeyValueDiffers},{type:i.ElementRef},{type:i.Renderer},{type:i.ComponentFactoryResolver},{type:i.ViewContainerRef}]},t.propDecorators={onDragStart:[{type:i.Output}],onDrag:[{type:i.Output}],onDragStop:[{type:i.Output}],onResizeStart:[{type:i.Output}],onResize:[{type:i.Output}],onResizeStop:[{type:i.Output}],onItemChange:[{type:i.Output}]},t}(),n=function(){function t(e,s,n,o,r){this._differs=e,this._ngEl=s,this._renderer=n,this._ngGrid=o,this.containerRef=r,this.onItemChange=new i.EventEmitter(!1),this.onDragStart=new i.EventEmitter,this.onDrag=new i.EventEmitter,this.onDragStop=new i.EventEmitter,this.onDragAny=new i.EventEmitter,this.onResizeStart=new i.EventEmitter,this.onResize=new i.EventEmitter,this.onResizeStop=new i.EventEmitter,this.onResizeAny=new i.EventEmitter,this.onChangeStart=new i.EventEmitter,this.onChange=new i.EventEmitter,this.onChangeStop=new i.EventEmitter,this.onChangeAny=new i.EventEmitter,this.ngGridItemChange=new i.EventEmitter,this.isFixed=!1,this.isDraggable=!0,this.isResizable=!0,this.minWidth=0,this.minHeight=0,this._position={col:1,row:1},this._currentPosition={col:1,row:1},this._size={x:1,y:1},this._config=t.CONST_DEFAULT_CONFIG,this._added=!1,this._maxCols=0,this._minCols=0,this._maxRows=0,this._minRows=0}return Object.defineProperty(t.prototype,\"config\",{set:function(i){var e=t.CONST_DEFAULT_CONFIG;for(var s in e)null==i[s]&&(i[s]=e[s]);this.setConfig(i),null==this._differ&&null!=i&&(this._differ=this._differs.find(this._config).create(null)),this._added||(this._added=!0,this._ngGrid.addItem(this)),this._recalculateDimensions(),this._recalculatePosition()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"sizex\",{get:function(){return this._size.x},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"sizey\",{get:function(){return this._size.y},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"col\",{get:function(){return this._position.col},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"row\",{get:function(){return this._position.row},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"currentCol\",{get:function(){return this._currentPosition.col},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,\"currentRow\",{get:function(){return this._currentPosition.row},enumerable:!0,configurable:!0}),t.prototype.onResizeStartEvent=function(){var t=this.getEventOutput();this.onResizeStart.emit(t),this.onResizeAny.emit(t),this.onChangeStart.emit(t),this.onChangeAny.emit(t)},t.prototype.onResizeEvent=function(){var t=this.getEventOutput();this.onResize.emit(t),this.onResizeAny.emit(t),this.onChange.emit(t),this.onChangeAny.emit(t)},t.prototype.onResizeStopEvent=function(){var t=this.getEventOutput();this.onResizeStop.emit(t),this.onResizeAny.emit(t),this.onChangeStop.emit(t),this.onChangeAny.emit(t),this._config.sizex=this._size.x,this._config.sizey=this._size.y,this.ngGridItemChange.emit(this._config)},t.prototype.onDragStartEvent=function(){var t=this.getEventOutput();this.onDragStart.emit(t),this.onDragAny.emit(t),this.onChangeStart.emit(t),this.onChangeAny.emit(t)},t.prototype.onDragEvent=function(){var t=this.getEventOutput();this.onDrag.emit(t),this.onDragAny.emit(t),this.onChange.emit(t),this.onChangeAny.emit(t)},t.prototype.onDragStopEvent=function(){var t=this.getEventOutput();this.onDragStop.emit(t),this.onDragAny.emit(t),this.onChangeStop.emit(t),this.onChangeAny.emit(t),this._config.col=this._position.col,this._config.row=this._position.row,this.ngGridItemChange.emit(this._config)},t.prototype.onCascadeEvent=function(){this._config.sizex=this._size.x,this._config.sizey=this._size.y,this._config.col=this._position.col,this._config.row=this._position.row,this.ngGridItemChange.emit(this._config)},t.prototype.ngOnInit=function(){this._renderer.setElementClass(this._ngEl.nativeElement,\"grid-item\",!0),this._ngGrid.autoStyle&&this._renderer.setElementStyle(this._ngEl.nativeElement,\"position\",\"absolute\"),this._recalculateDimensions(),this._recalculatePosition(),this._added||(this._added=!0,this._ngGrid.addItem(this))},t.prototype.canDrag=function(t){return!!this.isDraggable&&(!this._dragHandle||this.findHandle(this._dragHandle,t.target))},t.prototype.findHandle=function(t,i){for(var e=i;e&&e!=this._ngEl.nativeElement;){if(this.elementMatches(e,t))return!0;e=e.parentElement}return!1},t.prototype.canResize=function(t){if(!this.isResizable)return null;if(this._resizeHandle)return this.findHandle(this._resizeHandle,t.target)?\"both\":null;var i=this._getMousePosition(t);return i.left<this._elemWidth&&i.left>this._elemWidth-this._borderSize&&i.top<this._elemHeight&&i.top>this._elemHeight-this._borderSize?\"both\":i.left<this._elemWidth&&i.left>this._elemWidth-this._borderSize?\"width\":i.top<this._elemHeight&&i.top>this._elemHeight-this._borderSize?\"height\":null},t.prototype.onMouseMove=function(t){if(this._ngGrid.autoStyle)if(this._ngGrid.resizeEnable&&!this._resizeHandle&&this.isResizable){var i=this._getMousePosition(t);i.left<this._elemWidth&&i.left>this._elemWidth-this._borderSize&&i.top<this._elemHeight&&i.top>this._elemHeight-this._borderSize?this._renderer.setElementStyle(this._ngEl.nativeElement,\"cursor\",\"nwse-resize\"):i.left<this._elemWidth&&i.left>this._elemWidth-this._borderSize?this._renderer.setElementStyle(this._ngEl.nativeElement,\"cursor\",\"ew-resize\"):i.top<this._elemHeight&&i.top>this._elemHeight-this._borderSize?this._renderer.setElementStyle(this._ngEl.nativeElement,\"cursor\",\"ns-resize\"):this._ngGrid.dragEnable&&this.canDrag(t)?this._renderer.setElementStyle(this._ngEl.nativeElement,\"cursor\",\"move\"):this._renderer.setElementStyle(this._ngEl.nativeElement,\"cursor\",\"default\")}else this._ngGrid.resizeEnable&&this.canResize(t)?this._renderer.setElementStyle(this._ngEl.nativeElement,\"cursor\",\"nwse-resize\"):this._ngGrid.dragEnable&&this.canDrag(t)?this._renderer.setElementStyle(this._ngEl.nativeElement,\"cursor\",\"move\"):this._renderer.setElementStyle(this._ngEl.nativeElement,\"cursor\",\"default\");\n},t.prototype.ngOnDestroy=function(){this._added&&this._ngGrid.removeItem(this)},t.prototype.getElement=function(){return this._ngEl},t.prototype.getDragHandle=function(){return this._dragHandle},t.prototype.getResizeHandle=function(){return this._resizeHandle},t.prototype.getDimensions=function(){return{width:this._elemWidth,height:this._elemHeight}},t.prototype.getSize=function(){return this._size},t.prototype.getPosition=function(){return{left:this._elemLeft,top:this._elemTop}},t.prototype.getGridPosition=function(){return this._currentPosition},t.prototype.getSavedPosition=function(){return this._position},t.prototype.setConfig=function(i){this._config=i,this._payload=i.payload,this._position.col=this._currentPosition.col=i.col?i.col:t.CONST_DEFAULT_CONFIG.col,this._position.row=this._currentPosition.row=i.row?i.row:t.CONST_DEFAULT_CONFIG.row,this._size.x=i.sizex?i.sizex:t.CONST_DEFAULT_CONFIG.sizex,this._size.y=i.sizey?i.sizey:t.CONST_DEFAULT_CONFIG.sizey,this._dragHandle=i.dragHandle,this._resizeHandle=i.resizeHandle,this._borderSize=i.borderSize,this.isDraggable=!!i.draggable,this.isResizable=!!i.resizable,this.isFixed=!!i.fixed,this._maxCols=!isNaN(i.maxCols)&&isFinite(i.maxCols)?i.maxCols:0,this._minCols=!isNaN(i.minCols)&&isFinite(i.minCols)?i.minCols:0,this._maxRows=!isNaN(i.maxRows)&&isFinite(i.maxRows)?i.maxRows:0,this._minRows=!isNaN(i.minRows)&&isFinite(i.minRows)?i.minRows:0,this.minWidth=!isNaN(i.minWidth)&&isFinite(i.minWidth)?i.minWidth:0,this.minHeight=!isNaN(i.minHeight)&&isFinite(i.minHeight)?i.minHeight:0,this._minCols>0&&this._maxCols>0&&this._minCols>this._maxCols&&(this._minCols=0),this._minRows>0&&this._maxRows>0&&this._minRows>this._maxRows&&(this._minRows=0),this._added&&this._ngGrid.updateItem(this),this._size=this.fixResize(this._size),this._recalculatePosition(),this._recalculateDimensions()},t.prototype.ngDoCheck=function(){if(null!=this._differ){var t=this._differ.diff(this._config);if(null!=t)return this._applyChanges(t),!0}return!1},t.prototype.setSize=function(t,i){void 0===i&&(i=!0),t=this.fixResize(t),this._size=t,i&&this._recalculateDimensions(),this.onItemChange.emit(this.getEventOutput())},t.prototype.setGridPosition=function(t,i){void 0===i&&(i=!0),this._currentPosition=t,i&&this._recalculatePosition(),this.onItemChange.emit(this.getEventOutput())},t.prototype.savePosition=function(t){this._position=t,this._currentPosition=t,this._recalculatePosition(),this.onItemChange.emit(this.getEventOutput())},t.prototype.getEventOutput=function(){return{payload:this._payload,col:this._currentPosition.col,row:this._currentPosition.row,sizex:this._size.x,sizey:this._size.y,width:this._elemWidth,height:this._elemHeight,left:this._elemLeft,top:this._elemTop}},t.prototype.setPosition=function(t,i){switch(this._cascadeMode){case\"up\":case\"left\":default:this._renderer.setElementStyle(this._ngEl.nativeElement,\"transform\",\"translate(\"+t+\"px, \"+i+\"px)\");break;case\"right\":this._renderer.setElementStyle(this._ngEl.nativeElement,\"transform\",\"translate(\"+-t+\"px, \"+i+\"px)\");break;case\"down\":this._renderer.setElementStyle(this._ngEl.nativeElement,\"transform\",\"translate(\"+t+\"px, \"+-i+\"px)\")}this._elemLeft=t,this._elemTop=i},t.prototype.setCascadeMode=function(t){switch(this._cascadeMode=t,t){case\"up\":case\"left\":default:this._renderer.setElementStyle(this._ngEl.nativeElement,\"left\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"top\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"right\",null),this._renderer.setElementStyle(this._ngEl.nativeElement,\"bottom\",null);break;case\"right\":this._renderer.setElementStyle(this._ngEl.nativeElement,\"right\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"top\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"left\",null),this._renderer.setElementStyle(this._ngEl.nativeElement,\"bottom\",null);break;case\"down\":this._renderer.setElementStyle(this._ngEl.nativeElement,\"left\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"bottom\",\"0px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"right\",null),this._renderer.setElementStyle(this._ngEl.nativeElement,\"top\",null)}},t.prototype.setDimensions=function(t,i){t<this.minWidth&&(t=this.minWidth),i<this.minHeight&&(i=this.minHeight),this._renderer.setElementStyle(this._ngEl.nativeElement,\"width\",t+\"px\"),this._renderer.setElementStyle(this._ngEl.nativeElement,\"height\",i+\"px\"),this._elemWidth=t,this._elemHeight=i},t.prototype.startMoving=function(){this._renderer.setElementClass(this._ngEl.nativeElement,\"moving\",!0);var t=window.getComputedStyle(this._ngEl.nativeElement);this._ngGrid.autoStyle&&this._renderer.setElementStyle(this._ngEl.nativeElement,\"z-index\",(parseInt(t.getPropertyValue(\"z-index\"))+1).toString())},t.prototype.stopMoving=function(){this._renderer.setElementClass(this._ngEl.nativeElement,\"moving\",!1);var t=window.getComputedStyle(this._ngEl.nativeElement);this._ngGrid.autoStyle&&this._renderer.setElementStyle(this._ngEl.nativeElement,\"z-index\",(parseInt(t.getPropertyValue(\"z-index\"))-1).toString())},t.prototype.recalculateSelf=function(){this._recalculatePosition(),this._recalculateDimensions()},t.prototype.fixResize=function(t){this._maxCols>0&&t.x>this._maxCols&&(t.x=this._maxCols),this._maxRows>0&&t.y>this._maxRows&&(t.y=this._maxRows),this._minCols>0&&t.x<this._minCols&&(t.x=this._minCols),this._minRows>0&&t.y<this._minRows&&(t.y=this._minRows);var i=t.x*this._ngGrid.colWidth+(this._ngGrid.marginLeft+this._ngGrid.marginRight)*(t.x-1);i<this.minWidth&&(t.x=Math.ceil((this.minWidth+this._ngGrid.marginRight+this._ngGrid.marginLeft)/(this._ngGrid.colWidth+this._ngGrid.marginRight+this._ngGrid.marginLeft)));var e=t.y*this._ngGrid.rowHeight+(this._ngGrid.marginTop+this._ngGrid.marginBottom)*(t.y-1);return e<this.minHeight&&(t.y=Math.ceil((this.minHeight+this._ngGrid.marginBottom+this._ngGrid.marginTop)/(this._ngGrid.rowHeight+this._ngGrid.marginBottom+this._ngGrid.marginTop))),t},t.prototype.elementMatches=function(t,i){if(t.matches)return t.matches(i);if(t.oMatchesSelector)return t.oMatchesSelector(i);if(t.msMatchesSelector)return t.msMatchesSelector(i);if(t.mozMatchesSelector)return t.mozMatchesSelector(i);if(t.webkitMatchesSelector)return t.webkitMatchesSelector(i);for(var e=(t.document||t.ownerDocument).querySelectorAll(i),s=e.length;--s>=0&&e.item(s)!==t;);return s>-1},t.prototype._recalculatePosition=function(){var t=(this._ngGrid.colWidth+this._ngGrid.marginLeft+this._ngGrid.marginRight)*(this._currentPosition.col-1)+this._ngGrid.marginLeft,i=(this._ngGrid.rowHeight+this._ngGrid.marginTop+this._ngGrid.marginBottom)*(this._currentPosition.row-1)+this._ngGrid.marginTop;this.setPosition(t,i)},t.prototype._recalculateDimensions=function(){this._size.x<this._ngGrid.minCols&&(this._size.x=this._ngGrid.minCols),this._size.y<this._ngGrid.minRows&&(this._size.y=this._ngGrid.minRows);var t=this._ngGrid.colWidth*this._size.x+(this._ngGrid.marginLeft+this._ngGrid.marginRight)*(this._size.x-1),i=this._ngGrid.rowHeight*this._size.y+(this._ngGrid.marginTop+this._ngGrid.marginBottom)*(this._size.y-1),e=Math.max(this.minWidth,this._ngGrid.minWidth,t),s=Math.max(this.minHeight,this._ngGrid.minHeight,i);this.setDimensions(e,s)},t.prototype._getMousePosition=function(t){if(t.originalEvent&&t.originalEvent.touches){var i=t.originalEvent;t=i.touches.length?i.touches[0]:i.changedTouches.length?i.changedTouches[0]:t}else t.touches&&(t=t.touches.length?t.touches[0]:t.changedTouches.length?t.changedTouches[0]:t);var e=this._ngEl.nativeElement.getBoundingClientRect();return{left:t.clientX-e.left,top:t.clientY-e.top}},t.prototype._applyChanges=function(t){var i=this;t.forEachAddedItem(function(t){i._config[t.key]=t.currentValue}),t.forEachChangedItem(function(t){i._config[t.key]=t.currentValue}),t.forEachRemovedItem(function(t){delete i._config[t.key]}),this.setConfig(this._config)},t.CONST_DEFAULT_CONFIG={col:1,row:1,sizex:1,sizey:1,dragHandle:null,resizeHandle:null,fixed:!1,draggable:!0,resizable:!0,borderSize:25},t.decorators=[{type:i.Directive,args:[{selector:\"[ngGridItem]\",inputs:[\"config: ngGridItem\"]}]}],t.ctorParameters=function(){return[{type:i.KeyValueDiffers},{type:i.ElementRef},{type:i.Renderer},{type:s},{type:i.ViewContainerRef}]},t.propDecorators={onItemChange:[{type:i.Output}],onDragStart:[{type:i.Output}],onDrag:[{type:i.Output}],onDragStop:[{type:i.Output}],onDragAny:[{type:i.Output}],onResizeStart:[{type:i.Output}],onResize:[{type:i.Output}],onResizeStop:[{type:i.Output}],onResizeAny:[{type:i.Output}],onChangeStart:[{type:i.Output}],onChange:[{type:i.Output}],onChangeStop:[{type:i.Output}],onChangeAny:[{type:i.Output}],ngGridItemChange:[{type:i.Output}]},t}(),o=function(){function t(){}return t.decorators=[{type:i.NgModule,args:[{declarations:[s,n,e],entryComponents:[e],exports:[s,n]}]}],t.ctorParameters=function(){return[]},t}();t.NgGrid=s,t.NgGridItem=n,t.NgGridPlaceholder=e,t.NgGridModule=o,Object.defineProperty(t,\"__esModule\",{value:!0})});","/home/travis/build/npmtest/node-npmtest-angular2-grid/node_modules/angular2-grid/bundles/NgGrid.umd.js":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.grid = global.ng.grid || {}),global.ng.core));\n}(this, (function (exports,_angular_core) { 'use strict';\n\nvar NgGridPlaceholder = (function () {\n    function NgGridPlaceholder(_ngEl, _renderer) {\n        this._ngEl = _ngEl;\n        this._renderer = _renderer;\n    }\n    NgGridPlaceholder.prototype.registerGrid = function (ngGrid) {\n        this._ngGrid = ngGrid;\n    };\n    NgGridPlaceholder.prototype.ngOnInit = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'grid-placeholder', true);\n        if (this._ngGrid.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'position', 'absolute');\n    };\n    NgGridPlaceholder.prototype.setSize = function (newSize) {\n        this._size = newSize;\n        this._recalculateDimensions();\n    };\n    NgGridPlaceholder.prototype.setGridPosition = function (newPosition) {\n        this._position = newPosition;\n        this._recalculatePosition();\n    };\n    NgGridPlaceholder.prototype.setCascadeMode = function (cascade) {\n        this._cascadeMode = cascade;\n        switch (cascade) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', null);\n                break;\n        }\n    };\n    //\tPrivate methods\n    NgGridPlaceholder.prototype._setDimensions = function (w, h) {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'width', w + 'px');\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'height', h + 'px');\n    };\n    NgGridPlaceholder.prototype._setPosition = function (x, y) {\n        switch (this._cascadeMode) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + y + 'px)');\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + -x + 'px, ' + y + 'px)');\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + -y + 'px)');\n                break;\n        }\n    };\n    NgGridPlaceholder.prototype._recalculatePosition = function () {\n        var x = (this._ngGrid.colWidth + this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._position.col - 1) + this._ngGrid.marginLeft;\n        var y = (this._ngGrid.rowHeight + this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._position.row - 1) + this._ngGrid.marginTop;\n        this._setPosition(x, y);\n    };\n    NgGridPlaceholder.prototype._recalculateDimensions = function () {\n        var w = (this._ngGrid.colWidth * this._size.x) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._size.x - 1));\n        var h = (this._ngGrid.rowHeight * this._size.y) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._size.y - 1));\n        this._setDimensions(w, h);\n    };\n    NgGridPlaceholder.decorators = [\n        { type: _angular_core.Component, args: [{\n                    selector: 'ng-grid-placeholder',\n                    template: ''\n                },] },\n    ];\n    /** @nocollapse */\n    NgGridPlaceholder.ctorParameters = function () { return [\n        { type: _angular_core.ElementRef, },\n        { type: _angular_core.Renderer, },\n    ]; };\n    return NgGridPlaceholder;\n}());\n\nvar NgGrid = (function () {\n    //\tConstructor\n    function NgGrid(_differs, _ngEl, _renderer, componentFactoryResolver, _containerRef) {\n        this._differs = _differs;\n        this._ngEl = _ngEl;\n        this._renderer = _renderer;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this._containerRef = _containerRef;\n        //\tEvent Emitters\n        this.onDragStart = new _angular_core.EventEmitter();\n        this.onDrag = new _angular_core.EventEmitter();\n        this.onDragStop = new _angular_core.EventEmitter();\n        this.onResizeStart = new _angular_core.EventEmitter();\n        this.onResize = new _angular_core.EventEmitter();\n        this.onResizeStop = new _angular_core.EventEmitter();\n        this.onItemChange = new _angular_core.EventEmitter();\n        //\tPublic variables\n        this.colWidth = 250;\n        this.rowHeight = 250;\n        this.minCols = 1;\n        this.minRows = 1;\n        this.marginTop = 10;\n        this.marginRight = 10;\n        this.marginBottom = 10;\n        this.marginLeft = 10;\n        this.isDragging = false;\n        this.isResizing = false;\n        this.autoStyle = true;\n        this.resizeEnable = true;\n        this.dragEnable = true;\n        this.cascade = 'up';\n        this.minWidth = 100;\n        this.minHeight = 100;\n        //\tPrivate variables\n        this._items = [];\n        this._draggingItem = null;\n        this._resizingItem = null;\n        this._resizeDirection = null;\n        this._itemGrid = {}; //{ 1: { 1: null } };\n        this._maxCols = 0;\n        this._maxRows = 0;\n        this._visibleCols = 0;\n        this._visibleRows = 0;\n        this._setWidth = 250;\n        this._setHeight = 250;\n        this._posOffset = null;\n        this._adding = false;\n        this._placeholderRef = null;\n        this._fixToGrid = false;\n        this._autoResize = false;\n        this._destroyed = false;\n        this._maintainRatio = false;\n        this._preferNew = false;\n        this._zoomOnDrag = false;\n        this._limitToScreen = false;\n        this._curMaxRow = 0;\n        this._curMaxCol = 0;\n        this._dragReady = false;\n        this._resizeReady = false;\n        this._config = NgGrid.CONST_DEFAULT_CONFIG;\n    }\n    Object.defineProperty(NgGrid.prototype, \"config\", {\n        //\t[ng-grid] attribute handler\n        set: function (v) {\n            this.setConfig(v);\n            if (this._differ == null && v != null) {\n                this._differ = this._differs.find(this._config).create(null);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //\tPublic methods\n    NgGrid.prototype.ngOnInit = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'grid', true);\n        if (this.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'position', 'relative');\n        this.setConfig(this._config);\n    };\n    NgGrid.prototype.ngOnDestroy = function () {\n        this._destroyed = true;\n    };\n    NgGrid.prototype.setConfig = function (config) {\n        this._config = config;\n        var maxColRowChanged = false;\n        for (var x in config) {\n            var val = config[x];\n            var intVal = !val ? 0 : parseInt(val);\n            switch (x) {\n                case 'margins':\n                    this.setMargins(val);\n                    break;\n                case 'col_width':\n                    this.colWidth = Math.max(intVal, 1);\n                    break;\n                case 'row_height':\n                    this.rowHeight = Math.max(intVal, 1);\n                    break;\n                case 'auto_style':\n                    this.autoStyle = val ? true : false;\n                    break;\n                case 'auto_resize':\n                    this._autoResize = val ? true : false;\n                    break;\n                case 'draggable':\n                    this.dragEnable = val ? true : false;\n                    break;\n                case 'resizable':\n                    this.resizeEnable = val ? true : false;\n                    break;\n                case 'max_rows':\n                    maxColRowChanged = maxColRowChanged || this._maxRows != intVal;\n                    this._maxRows = intVal < 0 ? 0 : intVal;\n                    break;\n                case 'max_cols':\n                    maxColRowChanged = maxColRowChanged || this._maxCols != intVal;\n                    this._maxCols = intVal < 0 ? 0 : intVal;\n                    break;\n                case 'visible_rows':\n                    this._visibleRows = Math.max(intVal, 0);\n                    break;\n                case 'visible_cols':\n                    this._visibleCols = Math.max(intVal, 0);\n                    break;\n                case 'min_rows':\n                    this.minRows = Math.max(intVal, 1);\n                    break;\n                case 'min_cols':\n                    this.minCols = Math.max(intVal, 1);\n                    break;\n                case 'min_height':\n                    this.minHeight = Math.max(intVal, 1);\n                    break;\n                case 'min_width':\n                    this.minWidth = Math.max(intVal, 1);\n                    break;\n                case 'zoom_on_drag':\n                    this._zoomOnDrag = val ? true : false;\n                    break;\n                case 'cascade':\n                    if (this.cascade != val) {\n                        this.cascade = val;\n                        this._cascadeGrid();\n                    }\n                    break;\n                case 'fix_to_grid':\n                    this._fixToGrid = val ? true : false;\n                    break;\n                case 'maintain_ratio':\n                    this._maintainRatio = val ? true : false;\n                    break;\n                case 'prefer_new':\n                    this._preferNew = val ? true : false;\n                    break;\n                case 'limit_to_screen':\n                    this._limitToScreen = val ? true : false;\n                    break;\n            }\n        }\n        if (this._maintainRatio) {\n            if (this.colWidth && this.rowHeight) {\n                this._aspectRatio = this.colWidth / this.rowHeight;\n            }\n            else {\n                this._maintainRatio = false;\n            }\n        }\n        if (maxColRowChanged) {\n            if (this._maxCols > 0 && this._maxRows > 0) {\n                switch (this.cascade) {\n                    case 'left':\n                    case 'right':\n                        this._maxCols = 0;\n                        break;\n                    case 'up':\n                    case 'down':\n                    default:\n                        this._maxRows = 0;\n                        break;\n                }\n            }\n            for (var _i = 0, _a = this._items; _i < _a.length; _i++) {\n                var item = _a[_i];\n                var pos = item.getGridPosition();\n                var dims = item.getSize();\n                this._removeFromGrid(item);\n                if (this._maxCols > 0 && dims.x > this._maxCols) {\n                    dims.x = this._maxCols;\n                    item.setSize(dims);\n                }\n                else if (this._maxRows > 0 && dims.y > this._maxRows) {\n                    dims.y = this._maxRows;\n                    item.setSize(dims);\n                }\n                if (this._hasGridCollision(pos, dims) || !this._isWithinBounds(pos, dims)) {\n                    var newPosition = this._fixGridPosition(pos, dims);\n                    item.setGridPosition(newPosition);\n                }\n                this._addToGrid(item);\n            }\n            this._cascadeGrid();\n        }\n        this._calculateRowHeight();\n        this._calculateColWidth();\n        var maxWidth = this._maxCols * this.colWidth;\n        var maxHeight = this._maxRows * this.rowHeight;\n        if (maxWidth > 0 && this.minWidth > maxWidth)\n            this.minWidth = 0.75 * this.colWidth;\n        if (maxHeight > 0 && this.minHeight > maxHeight)\n            this.minHeight = 0.75 * this.rowHeight;\n        if (this.minWidth > this.colWidth)\n            this.minCols = Math.max(this.minCols, Math.ceil(this.minWidth / this.colWidth));\n        if (this.minHeight > this.rowHeight)\n            this.minRows = Math.max(this.minRows, Math.ceil(this.minHeight / this.rowHeight));\n        if (this._maxCols > 0 && this.minCols > this._maxCols)\n            this.minCols = 1;\n        if (this._maxRows > 0 && this.minRows > this._maxRows)\n            this.minRows = 1;\n        this._updateRatio();\n        for (var _b = 0, _c = this._items; _b < _c.length; _b++) {\n            var item = _c[_b];\n            this._removeFromGrid(item);\n            item.setCascadeMode(this.cascade);\n        }\n        this._updateLimit();\n        for (var _d = 0, _e = this._items; _d < _e.length; _d++) {\n            var item = _e[_d];\n            item.recalculateSelf();\n            this._addToGrid(item);\n        }\n        this._cascadeGrid();\n        this._updateSize();\n    };\n    NgGrid.prototype.getItemPosition = function (index) {\n        return this._items[index].getGridPosition();\n    };\n    NgGrid.prototype.getItemSize = function (index) {\n        return this._items[index].getSize();\n    };\n    NgGrid.prototype.ngDoCheck = function () {\n        if (this._differ != null) {\n            var changes = this._differ.diff(this._config);\n            if (changes != null) {\n                this._applyChanges(changes);\n                return true;\n            }\n        }\n        return false;\n    };\n    NgGrid.prototype.setMargins = function (margins) {\n        this.marginTop = Math.max(parseInt(margins[0]), 0);\n        this.marginRight = margins.length >= 2 ? Math.max(parseInt(margins[1]), 0) : this.marginTop;\n        this.marginBottom = margins.length >= 3 ? Math.max(parseInt(margins[2]), 0) : this.marginTop;\n        this.marginBottom = margins.length >= 3 ? Math.max(parseInt(margins[2]), 0) : this.marginTop;\n        this.marginLeft = margins.length >= 4 ? Math.max(parseInt(margins[3]), 0) : this.marginRight;\n    };\n    NgGrid.prototype.enableDrag = function () {\n        this.dragEnable = true;\n    };\n    NgGrid.prototype.disableDrag = function () {\n        this.dragEnable = false;\n    };\n    NgGrid.prototype.enableResize = function () {\n        this.resizeEnable = true;\n    };\n    NgGrid.prototype.disableResize = function () {\n        this.resizeEnable = false;\n    };\n    NgGrid.prototype.addItem = function (ngItem) {\n        ngItem.setCascadeMode(this.cascade);\n        if (!this._preferNew) {\n            var newPos = this._fixGridPosition(ngItem.getGridPosition(), ngItem.getSize());\n            ngItem.savePosition(newPos);\n        }\n        this._items.push(ngItem);\n        this._addToGrid(ngItem);\n        ngItem.recalculateSelf();\n        ngItem.onCascadeEvent();\n        this._emitOnItemChange();\n    };\n    NgGrid.prototype.removeItem = function (ngItem) {\n        this._removeFromGrid(ngItem);\n        for (var x = 0; x < this._items.length; x++) {\n            if (this._items[x] == ngItem) {\n                this._items.splice(x, 1);\n            }\n        }\n        if (this._destroyed)\n            return;\n        this._cascadeGrid();\n        this._updateSize();\n        this._items.forEach(function (item) { return item.recalculateSelf(); });\n        this._emitOnItemChange();\n    };\n    NgGrid.prototype.updateItem = function (ngItem) {\n        this._removeFromGrid(ngItem);\n        this._addToGrid(ngItem);\n        this._cascadeGrid();\n        this._updateSize();\n        ngItem.onCascadeEvent();\n    };\n    NgGrid.prototype.triggerCascade = function () {\n        this._cascadeGrid(null, null, false);\n    };\n    NgGrid.prototype.resizeEventHandler = function (e) {\n        this._calculateColWidth();\n        this._calculateRowHeight();\n        this._updateRatio();\n        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {\n            var item = _a[_i];\n            this._removeFromGrid(item);\n        }\n        this._updateLimit();\n        for (var _b = 0, _c = this._items; _b < _c.length; _b++) {\n            var item = _c[_b];\n            this._addToGrid(item);\n            item.recalculateSelf();\n        }\n        this._updateSize();\n    };\n    NgGrid.prototype.mouseDownEventHandler = function (e) {\n        var mousePos = this._getMousePosition(e);\n        var item = this._getItemFromPosition(mousePos);\n        if (item != null) {\n            if (this.resizeEnable && item.canResize(e)) {\n                this._resizeReady = true;\n            }\n            else if (this.dragEnable && item.canDrag(e)) {\n                this._dragReady = true;\n            }\n        }\n        return true;\n    };\n    NgGrid.prototype.mouseUpEventHandler = function (e) {\n        if (this.isDragging) {\n            this._dragStop(e);\n            return false;\n        }\n        else if (this.isResizing) {\n            this._resizeStop(e);\n            return false;\n        }\n        else if (this._dragReady || this._resizeReady) {\n            this._dragReady = false;\n            this._resizeReady = false;\n        }\n        return true;\n    };\n    NgGrid.prototype.mouseMoveEventHandler = function (e) {\n        if (this._resizeReady) {\n            this._resizeStart(e);\n            return;\n        }\n        else if (this._dragReady) {\n            this._dragStart(e);\n            return;\n        }\n        if (this.isDragging) {\n            this._drag(e);\n        }\n        else if (this.isResizing) {\n            this._resize(e);\n        }\n        else {\n            var mousePos = this._getMousePosition(e);\n            var item = this._getItemFromPosition(mousePos);\n            if (item) {\n                item.onMouseMove(e);\n            }\n        }\n    };\n    //\tPrivate methods\n    NgGrid.prototype._calculateColWidth = function () {\n        if (this._autoResize) {\n            if (this._maxCols > 0 || this._visibleCols > 0) {\n                var maxCols = this._maxCols > 0 ? this._maxCols : this._visibleCols;\n                var maxWidth = this._ngEl.nativeElement.getBoundingClientRect().width;\n                var colWidth = Math.floor(maxWidth / maxCols);\n                colWidth -= (this.marginLeft + this.marginRight);\n                if (colWidth > 0)\n                    this.colWidth = colWidth;\n                if (this.colWidth < this.minWidth || this.minCols > this._config.min_cols) {\n                    this.minCols = Math.max(this._config.min_cols, Math.ceil(this.minWidth / this.colWidth));\n                }\n            }\n        }\n    };\n    NgGrid.prototype._calculateRowHeight = function () {\n        if (this._autoResize) {\n            if (this._maxRows > 0 || this._visibleRows > 0) {\n                var maxRows = this._maxRows > 0 ? this._maxRows : this._visibleRows;\n                var maxHeight = window.innerHeight - this.marginTop - this.marginBottom;\n                var rowHeight = Math.max(Math.floor(maxHeight / maxRows), this.minHeight);\n                rowHeight -= (this.marginTop + this.marginBottom);\n                if (rowHeight > 0)\n                    this.rowHeight = rowHeight;\n                if (this.rowHeight < this.minHeight || this.minRows > this._config.min_rows) {\n                    this.minRows = Math.max(this._config.min_rows, Math.ceil(this.minHeight / this.rowHeight));\n                }\n            }\n        }\n    };\n    NgGrid.prototype._updateRatio = function () {\n        if (this._autoResize && this._maintainRatio) {\n            if (this._maxCols > 0 && this._visibleRows <= 0) {\n                this.rowHeight = this.colWidth / this._aspectRatio;\n            }\n            else if (this._maxRows > 0 && this._visibleCols <= 0) {\n                this.colWidth = this._aspectRatio * this.rowHeight;\n            }\n            else if (this._maxCols == 0 && this._maxRows == 0) {\n                if (this._visibleCols > 0) {\n                    this.rowHeight = this.colWidth / this._aspectRatio;\n                }\n                else if (this._visibleRows > 0) {\n                    this.colWidth = this._aspectRatio * this.rowHeight;\n                }\n            }\n        }\n    };\n    NgGrid.prototype._updateLimit = function () {\n        if (!this._autoResize && this._limitToScreen) {\n            this._limitGrid(this._getContainerColumns());\n        }\n    };\n    NgGrid.prototype._applyChanges = function (changes) {\n        var _this = this;\n        changes.forEachAddedItem(function (record) { _this._config[record.key] = record.currentValue; });\n        changes.forEachChangedItem(function (record) { _this._config[record.key] = record.currentValue; });\n        changes.forEachRemovedItem(function (record) { delete _this._config[record.key]; });\n        this.setConfig(this._config);\n    };\n    NgGrid.prototype._resizeStart = function (e) {\n        if (this.resizeEnable) {\n            var mousePos = this._getMousePosition(e);\n            var item = this._getItemFromPosition(mousePos);\n            if (item) {\n                item.startMoving();\n                this._resizingItem = item;\n                this._resizeDirection = item.canResize(e);\n                this._removeFromGrid(item);\n                this._createPlaceholder(item);\n                this.isResizing = true;\n                this._resizeReady = false;\n                this.onResizeStart.emit(item);\n                item.onResizeStartEvent();\n            }\n        }\n    };\n    NgGrid.prototype._dragStart = function (e) {\n        if (this.dragEnable) {\n            var mousePos = this._getMousePosition(e);\n            var item = this._getItemFromPosition(mousePos);\n            if (item) {\n                var itemPos = item.getPosition();\n                var pOffset = { 'left': (mousePos.left - itemPos.left), 'top': (mousePos.top - itemPos.top) };\n                item.startMoving();\n                this._draggingItem = item;\n                this._posOffset = pOffset;\n                this._removeFromGrid(item);\n                this._createPlaceholder(item);\n                this.isDragging = true;\n                this._dragReady = false;\n                this.onDragStart.emit(item);\n                item.onDragStartEvent();\n                if (this._zoomOnDrag) {\n                    this._zoomOut();\n                }\n            }\n        }\n    };\n    NgGrid.prototype._zoomOut = function () {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'scale(0.5, 0.5)');\n    };\n    NgGrid.prototype._resetZoom = function () {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', '');\n    };\n    NgGrid.prototype._drag = function (e) {\n        if (this.isDragging) {\n            if (window.getSelection) {\n                if (window.getSelection().empty) {\n                    window.getSelection().empty();\n                }\n                else if (window.getSelection().removeAllRanges) {\n                    window.getSelection().removeAllRanges();\n                }\n            }\n            else if (document.selection) {\n                document.selection.empty();\n            }\n            var mousePos = this._getMousePosition(e);\n            var newL = (mousePos.left - this._posOffset.left);\n            var newT = (mousePos.top - this._posOffset.top);\n            var itemPos = this._draggingItem.getGridPosition();\n            var gridPos = this._calculateGridPosition(newL, newT);\n            var dims = this._draggingItem.getSize();\n            if (!this._isWithinBoundsX(gridPos, dims))\n                gridPos.col = this._maxCols - (dims.x - 1);\n            if (!this._isWithinBoundsY(gridPos, dims))\n                gridPos.row = this._maxRows - (dims.y - 1);\n            if (!this._autoResize && this._limitToScreen) {\n                if ((gridPos.col + dims.x - 1) > this._getContainerColumns()) {\n                    gridPos.col = this._getContainerColumns() - (dims.x - 1);\n                }\n            }\n            if (gridPos.col != itemPos.col || gridPos.row != itemPos.row) {\n                this._draggingItem.setGridPosition(gridPos, this._fixToGrid);\n                this._placeholderRef.instance.setGridPosition(gridPos);\n                if (['up', 'down', 'left', 'right'].indexOf(this.cascade) >= 0) {\n                    this._fixGridCollisions(gridPos, dims, true);\n                    this._cascadeGrid(gridPos, dims);\n                }\n            }\n            if (!this._fixToGrid) {\n                this._draggingItem.setPosition(newL, newT);\n            }\n            this.onDrag.emit(this._draggingItem);\n            this._draggingItem.onDragEvent();\n        }\n    };\n    NgGrid.prototype._resize = function (e) {\n        if (this.isResizing) {\n            if (window.getSelection) {\n                if (window.getSelection().empty) {\n                    window.getSelection().empty();\n                }\n                else if (window.getSelection().removeAllRanges) {\n                    window.getSelection().removeAllRanges();\n                }\n            }\n            else if (document.selection) {\n                document.selection.empty();\n            }\n            var mousePos = this._getMousePosition(e);\n            var itemPos = this._resizingItem.getPosition();\n            var itemDims = this._resizingItem.getDimensions();\n            var newW = this._resizeDirection == 'height' ? itemDims.width : (mousePos.left - itemPos.left + 10);\n            var newH = this._resizeDirection == 'width' ? itemDims.height : (mousePos.top - itemPos.top + 10);\n            if (newW < this.minWidth)\n                newW = this.minWidth;\n            if (newH < this.minHeight)\n                newH = this.minHeight;\n            if (newW < this._resizingItem.minWidth)\n                newW = this._resizingItem.minWidth;\n            if (newH < this._resizingItem.minHeight)\n                newH = this._resizingItem.minHeight;\n            var calcSize = this._calculateGridSize(newW, newH);\n            var itemSize = this._resizingItem.getSize();\n            var iGridPos = this._resizingItem.getGridPosition();\n            if (!this._isWithinBoundsX(iGridPos, calcSize))\n                calcSize.x = (this._maxCols - iGridPos.col) + 1;\n            if (!this._isWithinBoundsY(iGridPos, calcSize))\n                calcSize.y = (this._maxRows - iGridPos.row) + 1;\n            calcSize = this._resizingItem.fixResize(calcSize);\n            if (calcSize.x != itemSize.x || calcSize.y != itemSize.y) {\n                this._resizingItem.setSize(calcSize, false);\n                this._placeholderRef.instance.setSize(calcSize);\n                if (['up', 'down', 'left', 'right'].indexOf(this.cascade) >= 0) {\n                    this._fixGridCollisions(iGridPos, calcSize, true);\n                    this._cascadeGrid(iGridPos, calcSize);\n                }\n            }\n            if (!this._fixToGrid)\n                this._resizingItem.setDimensions(newW, newH);\n            var bigGrid = this._maxGridSize(itemPos.left + newW + (2 * e.movementX), itemPos.top + newH + (2 * e.movementY));\n            if (this._resizeDirection == 'height')\n                bigGrid.x = iGridPos.col + itemSize.x;\n            if (this._resizeDirection == 'width')\n                bigGrid.y = iGridPos.row + itemSize.y;\n            this.onResize.emit(this._resizingItem);\n            this._resizingItem.onResizeEvent();\n        }\n    };\n    NgGrid.prototype._dragStop = function (e) {\n        if (this.isDragging) {\n            this.isDragging = false;\n            var itemPos = this._draggingItem.getGridPosition();\n            this._draggingItem.savePosition(itemPos);\n            this._addToGrid(this._draggingItem);\n            this._cascadeGrid();\n            this._draggingItem.stopMoving();\n            this._draggingItem.onDragStopEvent();\n            this.onDragStop.emit(this._draggingItem);\n            this._draggingItem = null;\n            this._posOffset = null;\n            this._placeholderRef.destroy();\n            this._emitOnItemChange();\n            if (this._zoomOnDrag) {\n                this._resetZoom();\n            }\n        }\n    };\n    NgGrid.prototype._resizeStop = function (e) {\n        if (this.isResizing) {\n            this.isResizing = false;\n            var itemDims = this._resizingItem.getSize();\n            this._resizingItem.setSize(itemDims);\n            this._addToGrid(this._resizingItem);\n            this._cascadeGrid();\n            this._resizingItem.stopMoving();\n            this._resizingItem.onResizeStopEvent();\n            this.onResizeStop.emit(this._resizingItem);\n            this._resizingItem = null;\n            this._resizeDirection = null;\n            this._placeholderRef.destroy();\n            this._emitOnItemChange();\n        }\n    };\n    NgGrid.prototype._maxGridSize = function (w, h) {\n        var sizex = Math.ceil(w / (this.colWidth + this.marginLeft + this.marginRight));\n        var sizey = Math.ceil(h / (this.rowHeight + this.marginTop + this.marginBottom));\n        return { 'x': sizex, 'y': sizey };\n    };\n    NgGrid.prototype._calculateGridSize = function (width, height) {\n        width += this.marginLeft + this.marginRight;\n        height += this.marginTop + this.marginBottom;\n        var sizex = Math.max(this.minCols, Math.round(width / (this.colWidth + this.marginLeft + this.marginRight)));\n        var sizey = Math.max(this.minRows, Math.round(height / (this.rowHeight + this.marginTop + this.marginBottom)));\n        if (!this._isWithinBoundsX({ col: 1, row: 1 }, { x: sizex, y: sizey }))\n            sizex = this._maxCols;\n        if (!this._isWithinBoundsY({ col: 1, row: 1 }, { x: sizex, y: sizey }))\n            sizey = this._maxRows;\n        return { 'x': sizex, 'y': sizey };\n    };\n    NgGrid.prototype._calculateGridPosition = function (left, top) {\n        var col = Math.max(1, Math.round(left / (this.colWidth + this.marginLeft + this.marginRight)) + 1);\n        var row = Math.max(1, Math.round(top / (this.rowHeight + this.marginTop + this.marginBottom)) + 1);\n        if (!this._isWithinBoundsX({ col: col, row: row }, { x: 1, y: 1 }))\n            col = this._maxCols;\n        if (!this._isWithinBoundsY({ col: col, row: row }, { x: 1, y: 1 }))\n            row = this._maxRows;\n        return { 'col': col, 'row': row };\n    };\n    NgGrid.prototype._hasGridCollision = function (pos, dims) {\n        var positions = this._getCollisions(pos, dims);\n        if (positions == null || positions.length == 0)\n            return false;\n        return positions.some(function (v) {\n            return !(v === null);\n        });\n    };\n    NgGrid.prototype._getCollisions = function (pos, dims) {\n        var returns = [];\n        for (var j = 0; j < dims.y; j++) {\n            if (this._itemGrid[pos.row + j] != null) {\n                for (var i = 0; i < dims.x; i++) {\n                    if (this._itemGrid[pos.row + j][pos.col + i] != null) {\n                        var item = this._itemGrid[pos.row + j][pos.col + i];\n                        if (returns.indexOf(item) < 0)\n                            returns.push(item);\n                        var itemPos = item.getGridPosition();\n                        var itemDims = item.getSize();\n                        i = itemPos.col + itemDims.x - pos.col;\n                    }\n                }\n            }\n        }\n        return returns;\n    };\n    NgGrid.prototype._fixGridCollisions = function (pos, dims, shouldSave) {\n        if (shouldSave === void 0) { shouldSave = false; }\n        while (this._hasGridCollision(pos, dims)) {\n            var collisions = this._getCollisions(pos, dims);\n            this._removeFromGrid(collisions[0]);\n            var itemPos = collisions[0].getGridPosition();\n            var itemDims = collisions[0].getSize();\n            switch (this.cascade) {\n                case 'up':\n                case 'down':\n                default:\n                    var oldRow = itemPos.row;\n                    itemPos.row = pos.row + dims.y;\n                    if (!this._isWithinBoundsY(itemPos, itemDims)) {\n                        itemPos.col = pos.col + dims.x;\n                        itemPos.row = oldRow;\n                    }\n                    break;\n                case 'left':\n                case 'right':\n                    var oldCol = itemPos.col;\n                    itemPos.col = pos.col + dims.x;\n                    if (!this._isWithinBoundsX(itemPos, itemDims)) {\n                        itemPos.col = oldCol;\n                        itemPos.row = pos.row + dims.y;\n                    }\n                    break;\n            }\n            if (shouldSave) {\n                collisions[0].savePosition(itemPos);\n            }\n            else {\n                collisions[0].setGridPosition(itemPos);\n            }\n            this._fixGridCollisions(itemPos, itemDims, shouldSave);\n            this._addToGrid(collisions[0]);\n            collisions[0].onCascadeEvent();\n        }\n    };\n    NgGrid.prototype._limitGrid = function (maxCols) {\n        var items = this._items.slice();\n        items.sort(function (a, b) {\n            var aPos = a.getSavedPosition();\n            var bPos = b.getSavedPosition();\n            if (aPos.row == bPos.row) {\n                return aPos.col == bPos.col ? 0 : (aPos.col < bPos.col ? -1 : 1);\n            }\n            else {\n                return aPos.row < bPos.row ? -1 : 1;\n            }\n        });\n        var columnMax = {};\n        var largestGap = {};\n        for (var i = 1; i <= maxCols; i++) {\n            columnMax[i] = 1;\n            largestGap[i] = 1;\n        }\n        var curPos = { col: 1, row: 1 };\n        var currentRow = 1;\n        var willCascade = function (item, col) {\n            for (var i = col; i < col + item.sizex; i++) {\n                if (columnMax[i] == currentRow)\n                    return true;\n            }\n            return false;\n        };\n        while (items.length > 0) {\n            var columns = [];\n            var newBlock = {\n                start: 1,\n                end: 1,\n                length: 0,\n            };\n            for (var col = 1; col <= maxCols; col++) {\n                if (columnMax[col] <= currentRow) {\n                    if (newBlock.length == 0) {\n                        newBlock.start = col;\n                    }\n                    newBlock.length++;\n                    newBlock.end = col + 1;\n                }\n                else if (newBlock.length > 0) {\n                    columns.push(newBlock);\n                    newBlock = {\n                        start: col,\n                        end: col,\n                        length: 0,\n                    };\n                }\n            }\n            if (newBlock.length > 0) {\n                columns.push(newBlock);\n            }\n            var tempColumns = columns.map(function (block) { return block.length; });\n            var currentItems = [];\n            while (items.length > 0) {\n                var item = items[0];\n                if (item.row > currentRow)\n                    break;\n                var fits = false;\n                for (var x in tempColumns) {\n                    if (item.sizex <= tempColumns[x]) {\n                        tempColumns[x] -= item.sizex;\n                        fits = true;\n                        break;\n                    }\n                    else if (item.sizex > tempColumns[x]) {\n                        tempColumns[x] = 0;\n                    }\n                }\n                if (fits) {\n                    currentItems.push(items.shift());\n                }\n                else {\n                    break;\n                }\n            }\n            if (currentItems.length > 0) {\n                var itemPositions = [];\n                var lastPosition = maxCols;\n                for (var i = currentItems.length - 1; i >= 0; i--) {\n                    var maxPosition = 1;\n                    for (var j = columns.length - 1; j >= 0; j--) {\n                        if (columns[j].start > lastPosition)\n                            continue;\n                        if (columns[j].start > (maxCols - currentItems[i].sizex))\n                            continue;\n                        if (columns[j].length < currentItems[i].sizex)\n                            continue;\n                        if (lastPosition < columns[j].end && (lastPosition - columns[j].start) < currentItems[i].sizex)\n                            continue;\n                        maxPosition = (lastPosition < columns[j].end ? lastPosition : columns[j].end) - currentItems[i].sizex;\n                        break;\n                    }\n                    itemPositions[i] = Math.min(maxPosition, currentItems[i].row == currentRow ? currentItems[i].col : 1);\n                    lastPosition = itemPositions[i];\n                }\n                var minPosition = 1;\n                var currentItem = 0;\n                while (currentItems.length > 0) {\n                    var item = currentItems.shift();\n                    for (var j = 0; j < columns.length; j++) {\n                        if (columns[j].length < item.sizex)\n                            continue;\n                        if (minPosition > columns[j].end)\n                            continue;\n                        if (minPosition > columns[j].start && (columns[j].end - minPosition) < item.sizex)\n                            continue;\n                        if (minPosition < columns[j].start)\n                            minPosition = columns[j].start;\n                        break;\n                    }\n                    item.setGridPosition({ col: Math.max(minPosition, itemPositions[currentItem]), row: currentRow });\n                    minPosition = item.currentCol + item.sizex;\n                    currentItem++;\n                    for (var i = item.currentCol; i < item.currentCol + item.sizex; i++) {\n                        columnMax[i] = item.currentRow + item.sizey;\n                    }\n                }\n            }\n            else if (currentItems.length === 0 && columns.length === 1 && columns[0].length >= maxCols) {\n                var item = items.shift();\n                item.setGridPosition({ col: 1, row: currentRow });\n                for (var i = item.currentCol; i < item.currentCol + item.sizex; i++) {\n                    columnMax[i] = item.currentRow + item.sizey;\n                }\n            }\n            var newRow = 0;\n            for (var x in columnMax) {\n                if (columnMax[x] > currentRow && (newRow == 0 || columnMax[x] < newRow)) {\n                    newRow = columnMax[x];\n                }\n            }\n            currentRow = newRow <= currentRow ? currentRow + 1 : newRow;\n        }\n    };\n    NgGrid.prototype._cascadeGrid = function (pos, dims, shouldSave) {\n        if (shouldSave === void 0) { shouldSave = true; }\n        if (this._destroyed)\n            return;\n        if (pos && !dims)\n            throw new Error('Cannot cascade with only position and not dimensions');\n        if (this.isDragging && this._draggingItem && !pos && !dims) {\n            pos = this._draggingItem.getGridPosition();\n            dims = this._draggingItem.getSize();\n        }\n        else if (this.isResizing && this._resizingItem && !pos && !dims) {\n            pos = this._resizingItem.getGridPosition();\n            dims = this._resizingItem.getSize();\n        }\n        switch (this.cascade) {\n            case 'up':\n            case 'down':\n                var lowRow = [0];\n                for (var i = 1; i <= this._curMaxCol; i++)\n                    lowRow[i] = 1;\n                for (var r = 1; r <= this._curMaxRow; r++) {\n                    if (this._itemGrid[r] == undefined)\n                        continue;\n                    for (var c = 1; c <= this._curMaxCol; c++) {\n                        if (this._itemGrid[r] == undefined)\n                            break;\n                        if (r < lowRow[c])\n                            continue;\n                        if (this._itemGrid[r][c] != null) {\n                            var item = this._itemGrid[r][c];\n                            if (item.isFixed)\n                                continue;\n                            var itemDims = item.getSize();\n                            var itemPos = item.getGridPosition();\n                            if (itemPos.col != c || itemPos.row != r)\n                                continue; //\tIf this is not the element's start\n                            var lowest = lowRow[c];\n                            for (var i = 1; i < itemDims.x; i++) {\n                                lowest = Math.max(lowRow[(c + i)], lowest);\n                            }\n                            if (pos && (c + itemDims.x) > pos.col && c < (pos.col + dims.x)) {\n                                if ((r >= pos.row && r < (pos.row + dims.y)) ||\n                                    ((itemDims.y > (pos.row - lowest)) &&\n                                        (r >= (pos.row + dims.y) && lowest < (pos.row + dims.y)))) {\n                                    lowest = Math.max(lowest, pos.row + dims.y); //\tSet the lowest row to be below it\n                                }\n                            }\n                            var newPos = { col: c, row: lowest };\n                            if (lowest != itemPos.row && this._isWithinBoundsY(newPos, itemDims)) {\n                                this._removeFromGrid(item);\n                                if (shouldSave) {\n                                    item.savePosition(newPos);\n                                }\n                                else {\n                                    item.setGridPosition(newPos);\n                                }\n                                item.onCascadeEvent();\n                                this._addToGrid(item);\n                            }\n                            for (var i = 0; i < itemDims.x; i++) {\n                                lowRow[c + i] = lowest + itemDims.y; //\tUpdate the lowest row to be below the item\n                            }\n                        }\n                    }\n                }\n                break;\n            case 'left':\n            case 'right':\n                var lowCol = [0];\n                for (var i = 1; i <= this._curMaxRow; i++)\n                    lowCol[i] = 1;\n                for (var r = 1; r <= this._curMaxRow; r++) {\n                    if (this._itemGrid[r] == undefined)\n                        continue;\n                    for (var c = 1; c <= this._curMaxCol; c++) {\n                        if (this._itemGrid[r] == undefined)\n                            break;\n                        if (c < lowCol[r])\n                            continue;\n                        if (this._itemGrid[r][c] != null) {\n                            var item = this._itemGrid[r][c];\n                            var itemDims = item.getSize();\n                            var itemPos = item.getGridPosition();\n                            if (itemPos.col != c || itemPos.row != r)\n                                continue; //\tIf this is not the element's start\n                            var lowest = lowCol[r];\n                            for (var i = 1; i < itemDims.y; i++) {\n                                lowest = Math.max(lowCol[(r + i)], lowest);\n                            }\n                            if (pos && (r + itemDims.y) > pos.row && r < (pos.row + dims.y)) {\n                                if ((c >= pos.col && c < (pos.col + dims.x)) ||\n                                    ((itemDims.x > (pos.col - lowest)) &&\n                                        (c >= (pos.col + dims.x) && lowest < (pos.col + dims.x)))) {\n                                    lowest = Math.max(lowest, pos.col + dims.x); //\tSet the lowest col to be below it\n                                }\n                            }\n                            var newPos = { col: lowest, row: r };\n                            if (lowest != itemPos.col && this._isWithinBoundsX(newPos, itemDims)) {\n                                this._removeFromGrid(item);\n                                if (shouldSave) {\n                                    item.savePosition(newPos);\n                                }\n                                else {\n                                    item.setGridPosition(newPos);\n                                }\n                                item.onCascadeEvent();\n                                this._addToGrid(item);\n                            }\n                            for (var i = 0; i < itemDims.y; i++) {\n                                lowCol[r + i] = lowest + itemDims.x; //\tUpdate the lowest col to be below the item\n                            }\n                        }\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    };\n    NgGrid.prototype._fixGridPosition = function (pos, dims) {\n        while (this._hasGridCollision(pos, dims) || !this._isWithinBounds(pos, dims)) {\n            if (this._hasGridCollision(pos, dims)) {\n                switch (this.cascade) {\n                    case 'up':\n                    case 'down':\n                    default:\n                        pos.row++;\n                        break;\n                    case 'left':\n                    case 'right':\n                        pos.col++;\n                        break;\n                }\n            }\n            if (!this._isWithinBoundsY(pos, dims)) {\n                pos.col++;\n                pos.row = 1;\n            }\n            if (!this._isWithinBoundsX(pos, dims)) {\n                pos.row++;\n                pos.col = 1;\n            }\n        }\n        return pos;\n    };\n    NgGrid.prototype._isWithinBoundsX = function (pos, dims) {\n        if (this._limitToScreen) {\n            return (pos.col + dims.x - 1) <= this._getContainerColumns();\n        }\n        else {\n            return (this._maxCols == 0 || (pos.col + dims.x - 1) <= this._maxCols);\n        }\n    };\n    NgGrid.prototype._isWithinBoundsY = function (pos, dims) {\n        return (this._maxRows == 0 || (pos.row + dims.y - 1) <= this._maxRows);\n    };\n    NgGrid.prototype._isWithinBounds = function (pos, dims) {\n        return this._isWithinBoundsX(pos, dims) && this._isWithinBoundsY(pos, dims);\n    };\n    NgGrid.prototype._addToGrid = function (item) {\n        var pos = item.getGridPosition();\n        var dims = item.getSize();\n        if (this._hasGridCollision(pos, dims)) {\n            this._fixGridCollisions(pos, dims);\n            pos = item.getGridPosition();\n        }\n        for (var j = 0; j < dims.y; j++) {\n            if (this._itemGrid[pos.row + j] == null)\n                this._itemGrid[pos.row + j] = {};\n            for (var i = 0; i < dims.x; i++) {\n                this._itemGrid[pos.row + j][pos.col + i] = item;\n                this._updateSize(pos.col + dims.x - 1, pos.row + dims.y - 1);\n            }\n        }\n    };\n    NgGrid.prototype._removeFromGrid = function (item) {\n        for (var y in this._itemGrid)\n            for (var x in this._itemGrid[y])\n                if (this._itemGrid[y][x] == item)\n                    delete this._itemGrid[y][x];\n    };\n    NgGrid.prototype._updateSize = function (col, row) {\n        if (this._destroyed)\n            return;\n        col = (col == undefined) ? this._getMaxCol() : col;\n        row = (row == undefined) ? this._getMaxRow() : row;\n        var maxCol = Math.max(this._curMaxCol, col);\n        var maxRow = Math.max(this._curMaxRow, row);\n        if (maxCol != this._curMaxCol || maxRow != this._curMaxRow) {\n            this._curMaxCol = maxCol;\n            this._curMaxRow = maxRow;\n        }\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'width', '100%'); //(maxCol * (this.colWidth + this.marginLeft + this.marginRight))+'px');\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'height', (this._getMaxRow() * (this.rowHeight + this.marginTop + this.marginBottom)) + 'px');\n    };\n    NgGrid.prototype._getMaxRow = function () {\n        return Math.max.apply(null, this._items.map(function (item) { return item.getGridPosition().row + item.getSize().y - 1; }));\n    };\n    NgGrid.prototype._getMaxCol = function () {\n        return Math.max.apply(null, this._items.map(function (item) { return item.getGridPosition().col + item.getSize().x - 1; }));\n    };\n    NgGrid.prototype._getMousePosition = function (e) {\n        if ((window.TouchEvent && e instanceof TouchEvent) || (e.touches || e.changedTouches)) {\n            e = e.touches.length > 0 ? e.touches[0] : e.changedTouches[0];\n        }\n        var refPos = this._ngEl.nativeElement.getBoundingClientRect();\n        var left = e.clientX - refPos.left;\n        var top = e.clientY - refPos.top;\n        if (this.cascade == 'down')\n            top = refPos.top + refPos.height - e.clientY;\n        if (this.cascade == 'right')\n            left = refPos.left + refPos.width - e.clientX;\n        if (this.isDragging && this._zoomOnDrag) {\n            left *= 2;\n            top *= 2;\n        }\n        return {\n            left: left,\n            top: top\n        };\n    };\n    NgGrid.prototype._getAbsoluteMousePosition = function (e) {\n        if ((window.TouchEvent && e instanceof TouchEvent) || (e.touches || e.changedTouches)) {\n            e = e.touches.length > 0 ? e.touches[0] : e.changedTouches[0];\n        }\n        return {\n            left: e.clientX,\n            top: e.clientY\n        };\n    };\n    NgGrid.prototype._getContainerColumns = function () {\n        var maxWidth = this._ngEl.nativeElement.getBoundingClientRect().width;\n        return Math.floor(maxWidth / (this.colWidth + this.marginLeft + this.marginRight));\n    };\n    NgGrid.prototype._getItemFromPosition = function (position) {\n        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {\n            var item = _a[_i];\n            var size = item.getDimensions();\n            var pos = item.getPosition();\n            if (position.left > (pos.left + this.marginLeft) && position.left < (pos.left + this.marginLeft + size.width) &&\n                position.top > (pos.top + this.marginTop) && position.top < (pos.top + this.marginTop + size.height)) {\n                return item;\n            }\n        }\n        return null;\n    };\n    NgGrid.prototype._createPlaceholder = function (item) {\n        var pos = item.getGridPosition();\n        var dims = item.getSize();\n        var factory = this.componentFactoryResolver.resolveComponentFactory(NgGridPlaceholder);\n        var componentRef = item.containerRef.createComponent(factory);\n        this._placeholderRef = componentRef;\n        var placeholder = componentRef.instance;\n        placeholder.registerGrid(this);\n        placeholder.setCascadeMode(this.cascade);\n        placeholder.setGridPosition({ col: pos.col, row: pos.row });\n        placeholder.setSize({ x: dims.x, y: dims.y });\n    };\n    NgGrid.prototype._emitOnItemChange = function () {\n        this.onItemChange.emit(this._items.map(function (item) { return item.getEventOutput(); }));\n    };\n    //\tDefault config\n    NgGrid.CONST_DEFAULT_CONFIG = {\n        margins: [10],\n        draggable: true,\n        resizable: true,\n        max_cols: 0,\n        max_rows: 0,\n        visible_cols: 0,\n        visible_rows: 0,\n        col_width: 250,\n        row_height: 250,\n        cascade: 'up',\n        min_width: 100,\n        min_height: 100,\n        fix_to_grid: false,\n        auto_style: true,\n        auto_resize: false,\n        maintain_ratio: false,\n        prefer_new: false,\n        zoom_on_drag: false\n    };\n    NgGrid.decorators = [\n        { type: _angular_core.Directive, args: [{\n                    selector: '[ngGrid]',\n                    inputs: ['config: ngGrid'],\n                    host: {\n                        '(mousedown)': 'mouseDownEventHandler($event)',\n                        '(mousemove)': 'mouseMoveEventHandler($event)',\n                        '(mouseup)': 'mouseUpEventHandler($event)',\n                        '(touchstart)': 'mouseDownEventHandler($event)',\n                        '(touchmove)': 'mouseMoveEventHandler($event)',\n                        '(touchend)': 'mouseUpEventHandler($event)',\n                        '(window:resize)': 'resizeEventHandler($event)',\n                        '(document:mousemove)': 'mouseMoveEventHandler($event)',\n                        '(document:mouseup)': 'mouseUpEventHandler($event)'\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    NgGrid.ctorParameters = function () { return [\n        { type: _angular_core.KeyValueDiffers, },\n        { type: _angular_core.ElementRef, },\n        { type: _angular_core.Renderer, },\n        { type: _angular_core.ComponentFactoryResolver, },\n        { type: _angular_core.ViewContainerRef, },\n    ]; };\n    NgGrid.propDecorators = {\n        'onDragStart': [{ type: _angular_core.Output },],\n        'onDrag': [{ type: _angular_core.Output },],\n        'onDragStop': [{ type: _angular_core.Output },],\n        'onResizeStart': [{ type: _angular_core.Output },],\n        'onResize': [{ type: _angular_core.Output },],\n        'onResizeStop': [{ type: _angular_core.Output },],\n        'onItemChange': [{ type: _angular_core.Output },],\n    };\n    return NgGrid;\n}());\n\nvar NgGridItem = (function () {\n    //\tConstructor\n    function NgGridItem(_differs, _ngEl, _renderer, _ngGrid, containerRef) {\n        this._differs = _differs;\n        this._ngEl = _ngEl;\n        this._renderer = _renderer;\n        this._ngGrid = _ngGrid;\n        this.containerRef = containerRef;\n        //\tEvent Emitters\n        this.onItemChange = new _angular_core.EventEmitter(false);\n        this.onDragStart = new _angular_core.EventEmitter();\n        this.onDrag = new _angular_core.EventEmitter();\n        this.onDragStop = new _angular_core.EventEmitter();\n        this.onDragAny = new _angular_core.EventEmitter();\n        this.onResizeStart = new _angular_core.EventEmitter();\n        this.onResize = new _angular_core.EventEmitter();\n        this.onResizeStop = new _angular_core.EventEmitter();\n        this.onResizeAny = new _angular_core.EventEmitter();\n        this.onChangeStart = new _angular_core.EventEmitter();\n        this.onChange = new _angular_core.EventEmitter();\n        this.onChangeStop = new _angular_core.EventEmitter();\n        this.onChangeAny = new _angular_core.EventEmitter();\n        this.ngGridItemChange = new _angular_core.EventEmitter();\n        this.isFixed = false;\n        this.isDraggable = true;\n        this.isResizable = true;\n        this.minWidth = 0;\n        this.minHeight = 0;\n        this._position = { col: 1, row: 1 };\n        this._currentPosition = { col: 1, row: 1 };\n        this._size = { x: 1, y: 1 };\n        this._config = NgGridItem.CONST_DEFAULT_CONFIG;\n        this._added = false;\n        this._maxCols = 0;\n        this._minCols = 0;\n        this._maxRows = 0;\n        this._minRows = 0;\n    }\n    Object.defineProperty(NgGridItem.prototype, \"config\", {\n        //\t[ng-grid-item] handler\n        set: function (v) {\n            var defaults = NgGridItem.CONST_DEFAULT_CONFIG;\n            for (var x in defaults)\n                if (v[x] == null)\n                    v[x] = defaults[x];\n            this.setConfig(v);\n            if (this._differ == null && v != null) {\n                this._differ = this._differs.find(this._config).create(null);\n            }\n            if (!this._added) {\n                this._added = true;\n                this._ngGrid.addItem(this);\n            }\n            this._recalculateDimensions();\n            this._recalculatePosition();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"sizex\", {\n        get: function () {\n            return this._size.x;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"sizey\", {\n        get: function () {\n            return this._size.y;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"col\", {\n        get: function () {\n            return this._position.col;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"row\", {\n        get: function () {\n            return this._position.row;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"currentCol\", {\n        get: function () {\n            return this._currentPosition.col;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"currentRow\", {\n        get: function () {\n            return this._currentPosition.row;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NgGridItem.prototype.onResizeStartEvent = function () {\n        var event = this.getEventOutput();\n        this.onResizeStart.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChangeStart.emit(event);\n        this.onChangeAny.emit(event);\n    };\n    NgGridItem.prototype.onResizeEvent = function () {\n        var event = this.getEventOutput();\n        this.onResize.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChange.emit(event);\n        this.onChangeAny.emit(event);\n    };\n    NgGridItem.prototype.onResizeStopEvent = function () {\n        var event = this.getEventOutput();\n        this.onResizeStop.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChangeStop.emit(event);\n        this.onChangeAny.emit(event);\n        this._config.sizex = this._size.x;\n        this._config.sizey = this._size.y;\n        this.ngGridItemChange.emit(this._config);\n    };\n    NgGridItem.prototype.onDragStartEvent = function () {\n        var event = this.getEventOutput();\n        this.onDragStart.emit(event);\n        this.onDragAny.emit(event);\n        this.onChangeStart.emit(event);\n        this.onChangeAny.emit(event);\n    };\n    NgGridItem.prototype.onDragEvent = function () {\n        var event = this.getEventOutput();\n        this.onDrag.emit(event);\n        this.onDragAny.emit(event);\n        this.onChange.emit(event);\n        this.onChangeAny.emit(event);\n    };\n    NgGridItem.prototype.onDragStopEvent = function () {\n        var event = this.getEventOutput();\n        this.onDragStop.emit(event);\n        this.onDragAny.emit(event);\n        this.onChangeStop.emit(event);\n        this.onChangeAny.emit(event);\n        this._config.col = this._position.col;\n        this._config.row = this._position.row;\n        this.ngGridItemChange.emit(this._config);\n    };\n    NgGridItem.prototype.onCascadeEvent = function () {\n        this._config.sizex = this._size.x;\n        this._config.sizey = this._size.y;\n        this._config.col = this._position.col;\n        this._config.row = this._position.row;\n        this.ngGridItemChange.emit(this._config);\n    };\n    NgGridItem.prototype.ngOnInit = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'grid-item', true);\n        if (this._ngGrid.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'position', 'absolute');\n        this._recalculateDimensions();\n        this._recalculatePosition();\n        if (!this._added) {\n            this._added = true;\n            this._ngGrid.addItem(this);\n        }\n    };\n    //\tPublic methods\n    NgGridItem.prototype.canDrag = function (e) {\n        if (!this.isDraggable)\n            return false;\n        if (this._dragHandle) {\n            return this.findHandle(this._dragHandle, e.target);\n        }\n        return true;\n    };\n    NgGridItem.prototype.findHandle = function (handleSelector, startElement) {\n        var targetElem = startElement;\n        while (targetElem && targetElem != this._ngEl.nativeElement) {\n            if (this.elementMatches(targetElem, handleSelector))\n                return true;\n            targetElem = targetElem.parentElement;\n        }\n        return false;\n    };\n    NgGridItem.prototype.canResize = function (e) {\n        if (!this.isResizable)\n            return null;\n        if (this._resizeHandle) {\n            return this.findHandle(this._resizeHandle, e.target) ? 'both' : null;\n        }\n        var mousePos = this._getMousePosition(e);\n        if (mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize\n            && mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize) {\n            return 'both';\n        }\n        else if (mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize) {\n            return 'width';\n        }\n        else if (mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize) {\n            return 'height';\n        }\n        return null;\n    };\n    NgGridItem.prototype.onMouseMove = function (e) {\n        if (this._ngGrid.autoStyle) {\n            if (this._ngGrid.resizeEnable && !this._resizeHandle && this.isResizable) {\n                var mousePos = this._getMousePosition(e);\n                if (mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize\n                    && mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize) {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'nwse-resize');\n                }\n                else if (mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize) {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'ew-resize');\n                }\n                else if (mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize) {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'ns-resize');\n                }\n                else if (this._ngGrid.dragEnable && this.canDrag(e)) {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'move');\n                }\n                else {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'default');\n                }\n            }\n            else if (this._ngGrid.resizeEnable && this.canResize(e)) {\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'nwse-resize');\n            }\n            else if (this._ngGrid.dragEnable && this.canDrag(e)) {\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'move');\n            }\n            else {\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'default');\n            }\n        }\n    };\n    NgGridItem.prototype.ngOnDestroy = function () {\n        if (this._added)\n            this._ngGrid.removeItem(this);\n    };\n    //\tGetters\n    NgGridItem.prototype.getElement = function () {\n        return this._ngEl;\n    };\n    NgGridItem.prototype.getDragHandle = function () {\n        return this._dragHandle;\n    };\n    NgGridItem.prototype.getResizeHandle = function () {\n        return this._resizeHandle;\n    };\n    NgGridItem.prototype.getDimensions = function () {\n        return { 'width': this._elemWidth, 'height': this._elemHeight };\n    };\n    NgGridItem.prototype.getSize = function () {\n        return this._size;\n    };\n    NgGridItem.prototype.getPosition = function () {\n        return { 'left': this._elemLeft, 'top': this._elemTop };\n    };\n    NgGridItem.prototype.getGridPosition = function () {\n        return this._currentPosition;\n    };\n    NgGridItem.prototype.getSavedPosition = function () {\n        return this._position;\n    };\n    //\tSetters\n    NgGridItem.prototype.setConfig = function (config) {\n        this._config = config;\n        this._payload = config.payload;\n        this._position.col = this._currentPosition.col = config.col ? config.col : NgGridItem.CONST_DEFAULT_CONFIG.col;\n        this._position.row = this._currentPosition.row = config.row ? config.row : NgGridItem.CONST_DEFAULT_CONFIG.row;\n        this._size.x = config.sizex ? config.sizex : NgGridItem.CONST_DEFAULT_CONFIG.sizex;\n        this._size.y = config.sizey ? config.sizey : NgGridItem.CONST_DEFAULT_CONFIG.sizey;\n        this._dragHandle = config.dragHandle;\n        this._resizeHandle = config.resizeHandle;\n        this._borderSize = config.borderSize;\n        this.isDraggable = config.draggable ? true : false;\n        this.isResizable = config.resizable ? true : false;\n        this.isFixed = config.fixed ? true : false;\n        this._maxCols = !isNaN(config.maxCols) && isFinite(config.maxCols) ? config.maxCols : 0;\n        this._minCols = !isNaN(config.minCols) && isFinite(config.minCols) ? config.minCols : 0;\n        this._maxRows = !isNaN(config.maxRows) && isFinite(config.maxRows) ? config.maxRows : 0;\n        this._minRows = !isNaN(config.minRows) && isFinite(config.minRows) ? config.minRows : 0;\n        this.minWidth = !isNaN(config.minWidth) && isFinite(config.minWidth) ? config.minWidth : 0;\n        this.minHeight = !isNaN(config.minHeight) && isFinite(config.minHeight) ? config.minHeight : 0;\n        if (this._minCols > 0 && this._maxCols > 0 && this._minCols > this._maxCols)\n            this._minCols = 0;\n        if (this._minRows > 0 && this._maxRows > 0 && this._minRows > this._maxRows)\n            this._minRows = 0;\n        if (this._added) {\n            this._ngGrid.updateItem(this);\n        }\n        this._size = this.fixResize(this._size);\n        this._recalculatePosition();\n        this._recalculateDimensions();\n    };\n    NgGridItem.prototype.ngDoCheck = function () {\n        if (this._differ != null) {\n            var changes = this._differ.diff(this._config);\n            if (changes != null) {\n                this._applyChanges(changes);\n                return true;\n            }\n        }\n        return false;\n    };\n    NgGridItem.prototype.setSize = function (newSize, update) {\n        if (update === void 0) { update = true; }\n        newSize = this.fixResize(newSize);\n        this._size = newSize;\n        if (update)\n            this._recalculateDimensions();\n        this.onItemChange.emit(this.getEventOutput());\n    };\n    NgGridItem.prototype.setGridPosition = function (gridPosition, update) {\n        if (update === void 0) { update = true; }\n        this._currentPosition = gridPosition;\n        if (update)\n            this._recalculatePosition();\n        this.onItemChange.emit(this.getEventOutput());\n    };\n    NgGridItem.prototype.savePosition = function (newPosition) {\n        this._position = newPosition;\n        this._currentPosition = newPosition;\n        this._recalculatePosition();\n        this.onItemChange.emit(this.getEventOutput());\n    };\n    NgGridItem.prototype.getEventOutput = function () {\n        return {\n            payload: this._payload,\n            col: this._currentPosition.col,\n            row: this._currentPosition.row,\n            sizex: this._size.x,\n            sizey: this._size.y,\n            width: this._elemWidth,\n            height: this._elemHeight,\n            left: this._elemLeft,\n            top: this._elemTop\n        };\n    };\n    NgGridItem.prototype.setPosition = function (x, y) {\n        switch (this._cascadeMode) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + y + 'px)');\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + -x + 'px, ' + y + 'px)');\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + -y + 'px)');\n                break;\n        }\n        this._elemLeft = x;\n        this._elemTop = y;\n    };\n    NgGridItem.prototype.setCascadeMode = function (cascade) {\n        this._cascadeMode = cascade;\n        switch (cascade) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', null);\n                break;\n        }\n    };\n    NgGridItem.prototype.setDimensions = function (w, h) {\n        if (w < this.minWidth)\n            w = this.minWidth;\n        if (h < this.minHeight)\n            h = this.minHeight;\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'width', w + 'px');\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'height', h + 'px');\n        this._elemWidth = w;\n        this._elemHeight = h;\n    };\n    NgGridItem.prototype.startMoving = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'moving', true);\n        var style = window.getComputedStyle(this._ngEl.nativeElement);\n        if (this._ngGrid.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'z-index', (parseInt(style.getPropertyValue('z-index')) + 1).toString());\n    };\n    NgGridItem.prototype.stopMoving = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'moving', false);\n        var style = window.getComputedStyle(this._ngEl.nativeElement);\n        if (this._ngGrid.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'z-index', (parseInt(style.getPropertyValue('z-index')) - 1).toString());\n    };\n    NgGridItem.prototype.recalculateSelf = function () {\n        this._recalculatePosition();\n        this._recalculateDimensions();\n    };\n    NgGridItem.prototype.fixResize = function (newSize) {\n        if (this._maxCols > 0 && newSize.x > this._maxCols)\n            newSize.x = this._maxCols;\n        if (this._maxRows > 0 && newSize.y > this._maxRows)\n            newSize.y = this._maxRows;\n        if (this._minCols > 0 && newSize.x < this._minCols)\n            newSize.x = this._minCols;\n        if (this._minRows > 0 && newSize.y < this._minRows)\n            newSize.y = this._minRows;\n        var itemWidth = (newSize.x * this._ngGrid.colWidth) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (newSize.x - 1));\n        if (itemWidth < this.minWidth)\n            newSize.x = Math.ceil((this.minWidth + this._ngGrid.marginRight + this._ngGrid.marginLeft) / (this._ngGrid.colWidth + this._ngGrid.marginRight + this._ngGrid.marginLeft));\n        var itemHeight = (newSize.y * this._ngGrid.rowHeight) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (newSize.y - 1));\n        if (itemHeight < this.minHeight)\n            newSize.y = Math.ceil((this.minHeight + this._ngGrid.marginBottom + this._ngGrid.marginTop) / (this._ngGrid.rowHeight + this._ngGrid.marginBottom + this._ngGrid.marginTop));\n        return newSize;\n    };\n    //\tPrivate methods\n    NgGridItem.prototype.elementMatches = function (element, selector) {\n        if (element.matches)\n            return element.matches(selector);\n        if (element.oMatchesSelector)\n            return element.oMatchesSelector(selector);\n        if (element.msMatchesSelector)\n            return element.msMatchesSelector(selector);\n        if (element.mozMatchesSelector)\n            return element.mozMatchesSelector(selector);\n        if (element.webkitMatchesSelector)\n            return element.webkitMatchesSelector(selector);\n        var matches = (element.document || element.ownerDocument).querySelectorAll(selector);\n        var i = matches.length;\n        while (--i >= 0 && matches.item(i) !== element) { }\n        return i > -1;\n    };\n    NgGridItem.prototype._recalculatePosition = function () {\n        var x = (this._ngGrid.colWidth + this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._currentPosition.col - 1) + this._ngGrid.marginLeft;\n        var y = (this._ngGrid.rowHeight + this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._currentPosition.row - 1) + this._ngGrid.marginTop;\n        this.setPosition(x, y);\n    };\n    NgGridItem.prototype._recalculateDimensions = function () {\n        if (this._size.x < this._ngGrid.minCols)\n            this._size.x = this._ngGrid.minCols;\n        if (this._size.y < this._ngGrid.minRows)\n            this._size.y = this._ngGrid.minRows;\n        var newWidth = (this._ngGrid.colWidth * this._size.x) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._size.x - 1));\n        var newHeight = (this._ngGrid.rowHeight * this._size.y) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._size.y - 1));\n        var w = Math.max(this.minWidth, this._ngGrid.minWidth, newWidth);\n        var h = Math.max(this.minHeight, this._ngGrid.minHeight, newHeight);\n        this.setDimensions(w, h);\n    };\n    NgGridItem.prototype._getMousePosition = function (e) {\n        if (e.originalEvent && e.originalEvent.touches) {\n            var oe = e.originalEvent;\n            e = oe.touches.length ? oe.touches[0] : (oe.changedTouches.length ? oe.changedTouches[0] : e);\n        }\n        else if (e.touches) {\n            e = e.touches.length ? e.touches[0] : (e.changedTouches.length ? e.changedTouches[0] : e);\n        }\n        var refPos = this._ngEl.nativeElement.getBoundingClientRect();\n        return {\n            left: e.clientX - refPos.left,\n            top: e.clientY - refPos.top\n        };\n    };\n    NgGridItem.prototype._applyChanges = function (changes) {\n        var _this = this;\n        changes.forEachAddedItem(function (record) { _this._config[record.key] = record.currentValue; });\n        changes.forEachChangedItem(function (record) { _this._config[record.key] = record.currentValue; });\n        changes.forEachRemovedItem(function (record) { delete _this._config[record.key]; });\n        this.setConfig(this._config);\n    };\n    //\tDefault config\n    NgGridItem.CONST_DEFAULT_CONFIG = {\n        col: 1,\n        row: 1,\n        sizex: 1,\n        sizey: 1,\n        dragHandle: null,\n        resizeHandle: null,\n        fixed: false,\n        draggable: true,\n        resizable: true,\n        borderSize: 25\n    };\n    NgGridItem.decorators = [\n        { type: _angular_core.Directive, args: [{\n                    selector: '[ngGridItem]',\n                    inputs: ['config: ngGridItem']\n                },] },\n    ];\n    /** @nocollapse */\n    NgGridItem.ctorParameters = function () { return [\n        { type: _angular_core.KeyValueDiffers, },\n        { type: _angular_core.ElementRef, },\n        { type: _angular_core.Renderer, },\n        { type: NgGrid, },\n        { type: _angular_core.ViewContainerRef, },\n    ]; };\n    NgGridItem.propDecorators = {\n        'onItemChange': [{ type: _angular_core.Output },],\n        'onDragStart': [{ type: _angular_core.Output },],\n        'onDrag': [{ type: _angular_core.Output },],\n        'onDragStop': [{ type: _angular_core.Output },],\n        'onDragAny': [{ type: _angular_core.Output },],\n        'onResizeStart': [{ type: _angular_core.Output },],\n        'onResize': [{ type: _angular_core.Output },],\n        'onResizeStop': [{ type: _angular_core.Output },],\n        'onResizeAny': [{ type: _angular_core.Output },],\n        'onChangeStart': [{ type: _angular_core.Output },],\n        'onChange': [{ type: _angular_core.Output },],\n        'onChangeStop': [{ type: _angular_core.Output },],\n        'onChangeAny': [{ type: _angular_core.Output },],\n        'ngGridItemChange': [{ type: _angular_core.Output },],\n    };\n    return NgGridItem;\n}());\n\nvar NgGridModule$$1 = (function () {\n    function NgGridModule$$1() {\n    }\n    NgGridModule$$1.decorators = [\n        { type: _angular_core.NgModule, args: [{\n                    declarations: [NgGrid, NgGridItem, NgGridPlaceholder],\n                    entryComponents: [NgGridPlaceholder],\n                    exports: [NgGrid, NgGridItem]\n                },] },\n    ];\n    /** @nocollapse */\n    NgGridModule$$1.ctorParameters = function () { return []; };\n    return NgGridModule$$1;\n}());\n\nexports.NgGrid = NgGrid;\nexports.NgGridItem = NgGridItem;\nexports.NgGridPlaceholder = NgGridPlaceholder;\nexports.NgGridModule = NgGridModule$$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","/home/travis/build/npmtest/node-npmtest-angular2-grid/node_modules/angular2-grid/components/NgGridPlaceholder.js":"import { Component, ElementRef, Renderer } from '@angular/core';\nexport var NgGridPlaceholder = (function () {\n    function NgGridPlaceholder(_ngEl, _renderer) {\n        this._ngEl = _ngEl;\n        this._renderer = _renderer;\n    }\n    NgGridPlaceholder.prototype.registerGrid = function (ngGrid) {\n        this._ngGrid = ngGrid;\n    };\n    NgGridPlaceholder.prototype.ngOnInit = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'grid-placeholder', true);\n        if (this._ngGrid.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'position', 'absolute');\n    };\n    NgGridPlaceholder.prototype.setSize = function (newSize) {\n        this._size = newSize;\n        this._recalculateDimensions();\n    };\n    NgGridPlaceholder.prototype.setGridPosition = function (newPosition) {\n        this._position = newPosition;\n        this._recalculatePosition();\n    };\n    NgGridPlaceholder.prototype.setCascadeMode = function (cascade) {\n        this._cascadeMode = cascade;\n        switch (cascade) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', null);\n                break;\n        }\n    };\n    //\tPrivate methods\n    NgGridPlaceholder.prototype._setDimensions = function (w, h) {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'width', w + 'px');\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'height', h + 'px');\n    };\n    NgGridPlaceholder.prototype._setPosition = function (x, y) {\n        switch (this._cascadeMode) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + y + 'px)');\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + -x + 'px, ' + y + 'px)');\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + -y + 'px)');\n                break;\n        }\n    };\n    NgGridPlaceholder.prototype._recalculatePosition = function () {\n        var x = (this._ngGrid.colWidth + this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._position.col - 1) + this._ngGrid.marginLeft;\n        var y = (this._ngGrid.rowHeight + this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._position.row - 1) + this._ngGrid.marginTop;\n        this._setPosition(x, y);\n    };\n    NgGridPlaceholder.prototype._recalculateDimensions = function () {\n        var w = (this._ngGrid.colWidth * this._size.x) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._size.x - 1));\n        var h = (this._ngGrid.rowHeight * this._size.y) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._size.y - 1));\n        this._setDimensions(w, h);\n    };\n    NgGridPlaceholder.decorators = [\n        { type: Component, args: [{\n                    selector: 'ng-grid-placeholder',\n                    template: ''\n                },] },\n    ];\n    /** @nocollapse */\n    NgGridPlaceholder.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: Renderer, },\n    ]; };\n    return NgGridPlaceholder;\n}());\n//# sourceMappingURL=NgGridPlaceholder.js.map","/home/travis/build/npmtest/node-npmtest-angular2-grid/node_modules/angular2-grid/directives/NgGrid.js":"import { Directive, ElementRef, Renderer, EventEmitter, ComponentFactoryResolver, KeyValueDiffers, ViewContainerRef, Output } from '@angular/core';\nimport { NgGridPlaceholder } from '../components/NgGridPlaceholder';\nexport var NgGrid = (function () {\n    //\tConstructor\n    function NgGrid(_differs, _ngEl, _renderer, componentFactoryResolver, _containerRef) {\n        this._differs = _differs;\n        this._ngEl = _ngEl;\n        this._renderer = _renderer;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this._containerRef = _containerRef;\n        //\tEvent Emitters\n        this.onDragStart = new EventEmitter();\n        this.onDrag = new EventEmitter();\n        this.onDragStop = new EventEmitter();\n        this.onResizeStart = new EventEmitter();\n        this.onResize = new EventEmitter();\n        this.onResizeStop = new EventEmitter();\n        this.onItemChange = new EventEmitter();\n        //\tPublic variables\n        this.colWidth = 250;\n        this.rowHeight = 250;\n        this.minCols = 1;\n        this.minRows = 1;\n        this.marginTop = 10;\n        this.marginRight = 10;\n        this.marginBottom = 10;\n        this.marginLeft = 10;\n        this.isDragging = false;\n        this.isResizing = false;\n        this.autoStyle = true;\n        this.resizeEnable = true;\n        this.dragEnable = true;\n        this.cascade = 'up';\n        this.minWidth = 100;\n        this.minHeight = 100;\n        //\tPrivate variables\n        this._items = [];\n        this._draggingItem = null;\n        this._resizingItem = null;\n        this._resizeDirection = null;\n        this._itemGrid = {}; //{ 1: { 1: null } };\n        this._maxCols = 0;\n        this._maxRows = 0;\n        this._visibleCols = 0;\n        this._visibleRows = 0;\n        this._setWidth = 250;\n        this._setHeight = 250;\n        this._posOffset = null;\n        this._adding = false;\n        this._placeholderRef = null;\n        this._fixToGrid = false;\n        this._autoResize = false;\n        this._destroyed = false;\n        this._maintainRatio = false;\n        this._preferNew = false;\n        this._zoomOnDrag = false;\n        this._limitToScreen = false;\n        this._curMaxRow = 0;\n        this._curMaxCol = 0;\n        this._dragReady = false;\n        this._resizeReady = false;\n        this._config = NgGrid.CONST_DEFAULT_CONFIG;\n    }\n    Object.defineProperty(NgGrid.prototype, \"config\", {\n        //\t[ng-grid] attribute handler\n        set: function (v) {\n            this.setConfig(v);\n            if (this._differ == null && v != null) {\n                this._differ = this._differs.find(this._config).create(null);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //\tPublic methods\n    NgGrid.prototype.ngOnInit = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'grid', true);\n        if (this.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'position', 'relative');\n        this.setConfig(this._config);\n    };\n    NgGrid.prototype.ngOnDestroy = function () {\n        this._destroyed = true;\n    };\n    NgGrid.prototype.setConfig = function (config) {\n        this._config = config;\n        var maxColRowChanged = false;\n        for (var x in config) {\n            var val = config[x];\n            var intVal = !val ? 0 : parseInt(val);\n            switch (x) {\n                case 'margins':\n                    this.setMargins(val);\n                    break;\n                case 'col_width':\n                    this.colWidth = Math.max(intVal, 1);\n                    break;\n                case 'row_height':\n                    this.rowHeight = Math.max(intVal, 1);\n                    break;\n                case 'auto_style':\n                    this.autoStyle = val ? true : false;\n                    break;\n                case 'auto_resize':\n                    this._autoResize = val ? true : false;\n                    break;\n                case 'draggable':\n                    this.dragEnable = val ? true : false;\n                    break;\n                case 'resizable':\n                    this.resizeEnable = val ? true : false;\n                    break;\n                case 'max_rows':\n                    maxColRowChanged = maxColRowChanged || this._maxRows != intVal;\n                    this._maxRows = intVal < 0 ? 0 : intVal;\n                    break;\n                case 'max_cols':\n                    maxColRowChanged = maxColRowChanged || this._maxCols != intVal;\n                    this._maxCols = intVal < 0 ? 0 : intVal;\n                    break;\n                case 'visible_rows':\n                    this._visibleRows = Math.max(intVal, 0);\n                    break;\n                case 'visible_cols':\n                    this._visibleCols = Math.max(intVal, 0);\n                    break;\n                case 'min_rows':\n                    this.minRows = Math.max(intVal, 1);\n                    break;\n                case 'min_cols':\n                    this.minCols = Math.max(intVal, 1);\n                    break;\n                case 'min_height':\n                    this.minHeight = Math.max(intVal, 1);\n                    break;\n                case 'min_width':\n                    this.minWidth = Math.max(intVal, 1);\n                    break;\n                case 'zoom_on_drag':\n                    this._zoomOnDrag = val ? true : false;\n                    break;\n                case 'cascade':\n                    if (this.cascade != val) {\n                        this.cascade = val;\n                        this._cascadeGrid();\n                    }\n                    break;\n                case 'fix_to_grid':\n                    this._fixToGrid = val ? true : false;\n                    break;\n                case 'maintain_ratio':\n                    this._maintainRatio = val ? true : false;\n                    break;\n                case 'prefer_new':\n                    this._preferNew = val ? true : false;\n                    break;\n                case 'limit_to_screen':\n                    this._limitToScreen = val ? true : false;\n                    break;\n            }\n        }\n        if (this._maintainRatio) {\n            if (this.colWidth && this.rowHeight) {\n                this._aspectRatio = this.colWidth / this.rowHeight;\n            }\n            else {\n                this._maintainRatio = false;\n            }\n        }\n        if (maxColRowChanged) {\n            if (this._maxCols > 0 && this._maxRows > 0) {\n                switch (this.cascade) {\n                    case 'left':\n                    case 'right':\n                        this._maxCols = 0;\n                        break;\n                    case 'up':\n                    case 'down':\n                    default:\n                        this._maxRows = 0;\n                        break;\n                }\n            }\n            for (var _i = 0, _a = this._items; _i < _a.length; _i++) {\n                var item = _a[_i];\n                var pos = item.getGridPosition();\n                var dims = item.getSize();\n                this._removeFromGrid(item);\n                if (this._maxCols > 0 && dims.x > this._maxCols) {\n                    dims.x = this._maxCols;\n                    item.setSize(dims);\n                }\n                else if (this._maxRows > 0 && dims.y > this._maxRows) {\n                    dims.y = this._maxRows;\n                    item.setSize(dims);\n                }\n                if (this._hasGridCollision(pos, dims) || !this._isWithinBounds(pos, dims)) {\n                    var newPosition = this._fixGridPosition(pos, dims);\n                    item.setGridPosition(newPosition);\n                }\n                this._addToGrid(item);\n            }\n            this._cascadeGrid();\n        }\n        this._calculateRowHeight();\n        this._calculateColWidth();\n        var maxWidth = this._maxCols * this.colWidth;\n        var maxHeight = this._maxRows * this.rowHeight;\n        if (maxWidth > 0 && this.minWidth > maxWidth)\n            this.minWidth = 0.75 * this.colWidth;\n        if (maxHeight > 0 && this.minHeight > maxHeight)\n            this.minHeight = 0.75 * this.rowHeight;\n        if (this.minWidth > this.colWidth)\n            this.minCols = Math.max(this.minCols, Math.ceil(this.minWidth / this.colWidth));\n        if (this.minHeight > this.rowHeight)\n            this.minRows = Math.max(this.minRows, Math.ceil(this.minHeight / this.rowHeight));\n        if (this._maxCols > 0 && this.minCols > this._maxCols)\n            this.minCols = 1;\n        if (this._maxRows > 0 && this.minRows > this._maxRows)\n            this.minRows = 1;\n        this._updateRatio();\n        for (var _b = 0, _c = this._items; _b < _c.length; _b++) {\n            var item = _c[_b];\n            this._removeFromGrid(item);\n            item.setCascadeMode(this.cascade);\n        }\n        this._updateLimit();\n        for (var _d = 0, _e = this._items; _d < _e.length; _d++) {\n            var item = _e[_d];\n            item.recalculateSelf();\n            this._addToGrid(item);\n        }\n        this._cascadeGrid();\n        this._updateSize();\n    };\n    NgGrid.prototype.getItemPosition = function (index) {\n        return this._items[index].getGridPosition();\n    };\n    NgGrid.prototype.getItemSize = function (index) {\n        return this._items[index].getSize();\n    };\n    NgGrid.prototype.ngDoCheck = function () {\n        if (this._differ != null) {\n            var changes = this._differ.diff(this._config);\n            if (changes != null) {\n                this._applyChanges(changes);\n                return true;\n            }\n        }\n        return false;\n    };\n    NgGrid.prototype.setMargins = function (margins) {\n        this.marginTop = Math.max(parseInt(margins[0]), 0);\n        this.marginRight = margins.length >= 2 ? Math.max(parseInt(margins[1]), 0) : this.marginTop;\n        this.marginBottom = margins.length >= 3 ? Math.max(parseInt(margins[2]), 0) : this.marginTop;\n        this.marginBottom = margins.length >= 3 ? Math.max(parseInt(margins[2]), 0) : this.marginTop;\n        this.marginLeft = margins.length >= 4 ? Math.max(parseInt(margins[3]), 0) : this.marginRight;\n    };\n    NgGrid.prototype.enableDrag = function () {\n        this.dragEnable = true;\n    };\n    NgGrid.prototype.disableDrag = function () {\n        this.dragEnable = false;\n    };\n    NgGrid.prototype.enableResize = function () {\n        this.resizeEnable = true;\n    };\n    NgGrid.prototype.disableResize = function () {\n        this.resizeEnable = false;\n    };\n    NgGrid.prototype.addItem = function (ngItem) {\n        ngItem.setCascadeMode(this.cascade);\n        if (!this._preferNew) {\n            var newPos = this._fixGridPosition(ngItem.getGridPosition(), ngItem.getSize());\n            ngItem.savePosition(newPos);\n        }\n        this._items.push(ngItem);\n        this._addToGrid(ngItem);\n        ngItem.recalculateSelf();\n        ngItem.onCascadeEvent();\n        this._emitOnItemChange();\n    };\n    NgGrid.prototype.removeItem = function (ngItem) {\n        this._removeFromGrid(ngItem);\n        for (var x = 0; x < this._items.length; x++) {\n            if (this._items[x] == ngItem) {\n                this._items.splice(x, 1);\n            }\n        }\n        if (this._destroyed)\n            return;\n        this._cascadeGrid();\n        this._updateSize();\n        this._items.forEach(function (item) { return item.recalculateSelf(); });\n        this._emitOnItemChange();\n    };\n    NgGrid.prototype.updateItem = function (ngItem) {\n        this._removeFromGrid(ngItem);\n        this._addToGrid(ngItem);\n        this._cascadeGrid();\n        this._updateSize();\n        ngItem.onCascadeEvent();\n    };\n    NgGrid.prototype.triggerCascade = function () {\n        this._cascadeGrid(null, null, false);\n    };\n    NgGrid.prototype.resizeEventHandler = function (e) {\n        this._calculateColWidth();\n        this._calculateRowHeight();\n        this._updateRatio();\n        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {\n            var item = _a[_i];\n            this._removeFromGrid(item);\n        }\n        this._updateLimit();\n        for (var _b = 0, _c = this._items; _b < _c.length; _b++) {\n            var item = _c[_b];\n            this._addToGrid(item);\n            item.recalculateSelf();\n        }\n        this._updateSize();\n    };\n    NgGrid.prototype.mouseDownEventHandler = function (e) {\n        var mousePos = this._getMousePosition(e);\n        var item = this._getItemFromPosition(mousePos);\n        if (item != null) {\n            if (this.resizeEnable && item.canResize(e)) {\n                this._resizeReady = true;\n            }\n            else if (this.dragEnable && item.canDrag(e)) {\n                this._dragReady = true;\n            }\n        }\n        return true;\n    };\n    NgGrid.prototype.mouseUpEventHandler = function (e) {\n        if (this.isDragging) {\n            this._dragStop(e);\n            return false;\n        }\n        else if (this.isResizing) {\n            this._resizeStop(e);\n            return false;\n        }\n        else if (this._dragReady || this._resizeReady) {\n            this._dragReady = false;\n            this._resizeReady = false;\n        }\n        return true;\n    };\n    NgGrid.prototype.mouseMoveEventHandler = function (e) {\n        if (this._resizeReady) {\n            this._resizeStart(e);\n            return;\n        }\n        else if (this._dragReady) {\n            this._dragStart(e);\n            return;\n        }\n        if (this.isDragging) {\n            this._drag(e);\n        }\n        else if (this.isResizing) {\n            this._resize(e);\n        }\n        else {\n            var mousePos = this._getMousePosition(e);\n            var item = this._getItemFromPosition(mousePos);\n            if (item) {\n                item.onMouseMove(e);\n            }\n        }\n    };\n    //\tPrivate methods\n    NgGrid.prototype._calculateColWidth = function () {\n        if (this._autoResize) {\n            if (this._maxCols > 0 || this._visibleCols > 0) {\n                var maxCols = this._maxCols > 0 ? this._maxCols : this._visibleCols;\n                var maxWidth = this._ngEl.nativeElement.getBoundingClientRect().width;\n                var colWidth = Math.floor(maxWidth / maxCols);\n                colWidth -= (this.marginLeft + this.marginRight);\n                if (colWidth > 0)\n                    this.colWidth = colWidth;\n                if (this.colWidth < this.minWidth || this.minCols > this._config.min_cols) {\n                    this.minCols = Math.max(this._config.min_cols, Math.ceil(this.minWidth / this.colWidth));\n                }\n            }\n        }\n    };\n    NgGrid.prototype._calculateRowHeight = function () {\n        if (this._autoResize) {\n            if (this._maxRows > 0 || this._visibleRows > 0) {\n                var maxRows = this._maxRows > 0 ? this._maxRows : this._visibleRows;\n                var maxHeight = window.innerHeight - this.marginTop - this.marginBottom;\n                var rowHeight = Math.max(Math.floor(maxHeight / maxRows), this.minHeight);\n                rowHeight -= (this.marginTop + this.marginBottom);\n                if (rowHeight > 0)\n                    this.rowHeight = rowHeight;\n                if (this.rowHeight < this.minHeight || this.minRows > this._config.min_rows) {\n                    this.minRows = Math.max(this._config.min_rows, Math.ceil(this.minHeight / this.rowHeight));\n                }\n            }\n        }\n    };\n    NgGrid.prototype._updateRatio = function () {\n        if (this._autoResize && this._maintainRatio) {\n            if (this._maxCols > 0 && this._visibleRows <= 0) {\n                this.rowHeight = this.colWidth / this._aspectRatio;\n            }\n            else if (this._maxRows > 0 && this._visibleCols <= 0) {\n                this.colWidth = this._aspectRatio * this.rowHeight;\n            }\n            else if (this._maxCols == 0 && this._maxRows == 0) {\n                if (this._visibleCols > 0) {\n                    this.rowHeight = this.colWidth / this._aspectRatio;\n                }\n                else if (this._visibleRows > 0) {\n                    this.colWidth = this._aspectRatio * this.rowHeight;\n                }\n            }\n        }\n    };\n    NgGrid.prototype._updateLimit = function () {\n        if (!this._autoResize && this._limitToScreen) {\n            this._limitGrid(this._getContainerColumns());\n        }\n    };\n    NgGrid.prototype._applyChanges = function (changes) {\n        var _this = this;\n        changes.forEachAddedItem(function (record) { _this._config[record.key] = record.currentValue; });\n        changes.forEachChangedItem(function (record) { _this._config[record.key] = record.currentValue; });\n        changes.forEachRemovedItem(function (record) { delete _this._config[record.key]; });\n        this.setConfig(this._config);\n    };\n    NgGrid.prototype._resizeStart = function (e) {\n        if (this.resizeEnable) {\n            var mousePos = this._getMousePosition(e);\n            var item = this._getItemFromPosition(mousePos);\n            if (item) {\n                item.startMoving();\n                this._resizingItem = item;\n                this._resizeDirection = item.canResize(e);\n                this._removeFromGrid(item);\n                this._createPlaceholder(item);\n                this.isResizing = true;\n                this._resizeReady = false;\n                this.onResizeStart.emit(item);\n                item.onResizeStartEvent();\n            }\n        }\n    };\n    NgGrid.prototype._dragStart = function (e) {\n        if (this.dragEnable) {\n            var mousePos = this._getMousePosition(e);\n            var item = this._getItemFromPosition(mousePos);\n            if (item) {\n                var itemPos = item.getPosition();\n                var pOffset = { 'left': (mousePos.left - itemPos.left), 'top': (mousePos.top - itemPos.top) };\n                item.startMoving();\n                this._draggingItem = item;\n                this._posOffset = pOffset;\n                this._removeFromGrid(item);\n                this._createPlaceholder(item);\n                this.isDragging = true;\n                this._dragReady = false;\n                this.onDragStart.emit(item);\n                item.onDragStartEvent();\n                if (this._zoomOnDrag) {\n                    this._zoomOut();\n                }\n            }\n        }\n    };\n    NgGrid.prototype._zoomOut = function () {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'scale(0.5, 0.5)');\n    };\n    NgGrid.prototype._resetZoom = function () {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', '');\n    };\n    NgGrid.prototype._drag = function (e) {\n        if (this.isDragging) {\n            if (window.getSelection) {\n                if (window.getSelection().empty) {\n                    window.getSelection().empty();\n                }\n                else if (window.getSelection().removeAllRanges) {\n                    window.getSelection().removeAllRanges();\n                }\n            }\n            else if (document.selection) {\n                document.selection.empty();\n            }\n            var mousePos = this._getMousePosition(e);\n            var newL = (mousePos.left - this._posOffset.left);\n            var newT = (mousePos.top - this._posOffset.top);\n            var itemPos = this._draggingItem.getGridPosition();\n            var gridPos = this._calculateGridPosition(newL, newT);\n            var dims = this._draggingItem.getSize();\n            if (!this._isWithinBoundsX(gridPos, dims))\n                gridPos.col = this._maxCols - (dims.x - 1);\n            if (!this._isWithinBoundsY(gridPos, dims))\n                gridPos.row = this._maxRows - (dims.y - 1);\n            if (!this._autoResize && this._limitToScreen) {\n                if ((gridPos.col + dims.x - 1) > this._getContainerColumns()) {\n                    gridPos.col = this._getContainerColumns() - (dims.x - 1);\n                }\n            }\n            if (gridPos.col != itemPos.col || gridPos.row != itemPos.row) {\n                this._draggingItem.setGridPosition(gridPos, this._fixToGrid);\n                this._placeholderRef.instance.setGridPosition(gridPos);\n                if (['up', 'down', 'left', 'right'].indexOf(this.cascade) >= 0) {\n                    this._fixGridCollisions(gridPos, dims, true);\n                    this._cascadeGrid(gridPos, dims);\n                }\n            }\n            if (!this._fixToGrid) {\n                this._draggingItem.setPosition(newL, newT);\n            }\n            this.onDrag.emit(this._draggingItem);\n            this._draggingItem.onDragEvent();\n        }\n    };\n    NgGrid.prototype._resize = function (e) {\n        if (this.isResizing) {\n            if (window.getSelection) {\n                if (window.getSelection().empty) {\n                    window.getSelection().empty();\n                }\n                else if (window.getSelection().removeAllRanges) {\n                    window.getSelection().removeAllRanges();\n                }\n            }\n            else if (document.selection) {\n                document.selection.empty();\n            }\n            var mousePos = this._getMousePosition(e);\n            var itemPos = this._resizingItem.getPosition();\n            var itemDims = this._resizingItem.getDimensions();\n            var newW = this._resizeDirection == 'height' ? itemDims.width : (mousePos.left - itemPos.left + 10);\n            var newH = this._resizeDirection == 'width' ? itemDims.height : (mousePos.top - itemPos.top + 10);\n            if (newW < this.minWidth)\n                newW = this.minWidth;\n            if (newH < this.minHeight)\n                newH = this.minHeight;\n            if (newW < this._resizingItem.minWidth)\n                newW = this._resizingItem.minWidth;\n            if (newH < this._resizingItem.minHeight)\n                newH = this._resizingItem.minHeight;\n            var calcSize = this._calculateGridSize(newW, newH);\n            var itemSize = this._resizingItem.getSize();\n            var iGridPos = this._resizingItem.getGridPosition();\n            if (!this._isWithinBoundsX(iGridPos, calcSize))\n                calcSize.x = (this._maxCols - iGridPos.col) + 1;\n            if (!this._isWithinBoundsY(iGridPos, calcSize))\n                calcSize.y = (this._maxRows - iGridPos.row) + 1;\n            calcSize = this._resizingItem.fixResize(calcSize);\n            if (calcSize.x != itemSize.x || calcSize.y != itemSize.y) {\n                this._resizingItem.setSize(calcSize, false);\n                this._placeholderRef.instance.setSize(calcSize);\n                if (['up', 'down', 'left', 'right'].indexOf(this.cascade) >= 0) {\n                    this._fixGridCollisions(iGridPos, calcSize, true);\n                    this._cascadeGrid(iGridPos, calcSize);\n                }\n            }\n            if (!this._fixToGrid)\n                this._resizingItem.setDimensions(newW, newH);\n            var bigGrid = this._maxGridSize(itemPos.left + newW + (2 * e.movementX), itemPos.top + newH + (2 * e.movementY));\n            if (this._resizeDirection == 'height')\n                bigGrid.x = iGridPos.col + itemSize.x;\n            if (this._resizeDirection == 'width')\n                bigGrid.y = iGridPos.row + itemSize.y;\n            this.onResize.emit(this._resizingItem);\n            this._resizingItem.onResizeEvent();\n        }\n    };\n    NgGrid.prototype._dragStop = function (e) {\n        if (this.isDragging) {\n            this.isDragging = false;\n            var itemPos = this._draggingItem.getGridPosition();\n            this._draggingItem.savePosition(itemPos);\n            this._addToGrid(this._draggingItem);\n            this._cascadeGrid();\n            this._draggingItem.stopMoving();\n            this._draggingItem.onDragStopEvent();\n            this.onDragStop.emit(this._draggingItem);\n            this._draggingItem = null;\n            this._posOffset = null;\n            this._placeholderRef.destroy();\n            this._emitOnItemChange();\n            if (this._zoomOnDrag) {\n                this._resetZoom();\n            }\n        }\n    };\n    NgGrid.prototype._resizeStop = function (e) {\n        if (this.isResizing) {\n            this.isResizing = false;\n            var itemDims = this._resizingItem.getSize();\n            this._resizingItem.setSize(itemDims);\n            this._addToGrid(this._resizingItem);\n            this._cascadeGrid();\n            this._resizingItem.stopMoving();\n            this._resizingItem.onResizeStopEvent();\n            this.onResizeStop.emit(this._resizingItem);\n            this._resizingItem = null;\n            this._resizeDirection = null;\n            this._placeholderRef.destroy();\n            this._emitOnItemChange();\n        }\n    };\n    NgGrid.prototype._maxGridSize = function (w, h) {\n        var sizex = Math.ceil(w / (this.colWidth + this.marginLeft + this.marginRight));\n        var sizey = Math.ceil(h / (this.rowHeight + this.marginTop + this.marginBottom));\n        return { 'x': sizex, 'y': sizey };\n    };\n    NgGrid.prototype._calculateGridSize = function (width, height) {\n        width += this.marginLeft + this.marginRight;\n        height += this.marginTop + this.marginBottom;\n        var sizex = Math.max(this.minCols, Math.round(width / (this.colWidth + this.marginLeft + this.marginRight)));\n        var sizey = Math.max(this.minRows, Math.round(height / (this.rowHeight + this.marginTop + this.marginBottom)));\n        if (!this._isWithinBoundsX({ col: 1, row: 1 }, { x: sizex, y: sizey }))\n            sizex = this._maxCols;\n        if (!this._isWithinBoundsY({ col: 1, row: 1 }, { x: sizex, y: sizey }))\n            sizey = this._maxRows;\n        return { 'x': sizex, 'y': sizey };\n    };\n    NgGrid.prototype._calculateGridPosition = function (left, top) {\n        var col = Math.max(1, Math.round(left / (this.colWidth + this.marginLeft + this.marginRight)) + 1);\n        var row = Math.max(1, Math.round(top / (this.rowHeight + this.marginTop + this.marginBottom)) + 1);\n        if (!this._isWithinBoundsX({ col: col, row: row }, { x: 1, y: 1 }))\n            col = this._maxCols;\n        if (!this._isWithinBoundsY({ col: col, row: row }, { x: 1, y: 1 }))\n            row = this._maxRows;\n        return { 'col': col, 'row': row };\n    };\n    NgGrid.prototype._hasGridCollision = function (pos, dims) {\n        var positions = this._getCollisions(pos, dims);\n        if (positions == null || positions.length == 0)\n            return false;\n        return positions.some(function (v) {\n            return !(v === null);\n        });\n    };\n    NgGrid.prototype._getCollisions = function (pos, dims) {\n        var returns = [];\n        for (var j = 0; j < dims.y; j++) {\n            if (this._itemGrid[pos.row + j] != null) {\n                for (var i = 0; i < dims.x; i++) {\n                    if (this._itemGrid[pos.row + j][pos.col + i] != null) {\n                        var item = this._itemGrid[pos.row + j][pos.col + i];\n                        if (returns.indexOf(item) < 0)\n                            returns.push(item);\n                        var itemPos = item.getGridPosition();\n                        var itemDims = item.getSize();\n                        i = itemPos.col + itemDims.x - pos.col;\n                    }\n                }\n            }\n        }\n        return returns;\n    };\n    NgGrid.prototype._fixGridCollisions = function (pos, dims, shouldSave) {\n        if (shouldSave === void 0) { shouldSave = false; }\n        while (this._hasGridCollision(pos, dims)) {\n            var collisions = this._getCollisions(pos, dims);\n            this._removeFromGrid(collisions[0]);\n            var itemPos = collisions[0].getGridPosition();\n            var itemDims = collisions[0].getSize();\n            switch (this.cascade) {\n                case 'up':\n                case 'down':\n                default:\n                    var oldRow = itemPos.row;\n                    itemPos.row = pos.row + dims.y;\n                    if (!this._isWithinBoundsY(itemPos, itemDims)) {\n                        itemPos.col = pos.col + dims.x;\n                        itemPos.row = oldRow;\n                    }\n                    break;\n                case 'left':\n                case 'right':\n                    var oldCol = itemPos.col;\n                    itemPos.col = pos.col + dims.x;\n                    if (!this._isWithinBoundsX(itemPos, itemDims)) {\n                        itemPos.col = oldCol;\n                        itemPos.row = pos.row + dims.y;\n                    }\n                    break;\n            }\n            if (shouldSave) {\n                collisions[0].savePosition(itemPos);\n            }\n            else {\n                collisions[0].setGridPosition(itemPos);\n            }\n            this._fixGridCollisions(itemPos, itemDims, shouldSave);\n            this._addToGrid(collisions[0]);\n            collisions[0].onCascadeEvent();\n        }\n    };\n    NgGrid.prototype._limitGrid = function (maxCols) {\n        var items = this._items.slice();\n        items.sort(function (a, b) {\n            var aPos = a.getSavedPosition();\n            var bPos = b.getSavedPosition();\n            if (aPos.row == bPos.row) {\n                return aPos.col == bPos.col ? 0 : (aPos.col < bPos.col ? -1 : 1);\n            }\n            else {\n                return aPos.row < bPos.row ? -1 : 1;\n            }\n        });\n        var columnMax = {};\n        var largestGap = {};\n        for (var i = 1; i <= maxCols; i++) {\n            columnMax[i] = 1;\n            largestGap[i] = 1;\n        }\n        var curPos = { col: 1, row: 1 };\n        var currentRow = 1;\n        var willCascade = function (item, col) {\n            for (var i = col; i < col + item.sizex; i++) {\n                if (columnMax[i] == currentRow)\n                    return true;\n            }\n            return false;\n        };\n        while (items.length > 0) {\n            var columns = [];\n            var newBlock = {\n                start: 1,\n                end: 1,\n                length: 0,\n            };\n            for (var col = 1; col <= maxCols; col++) {\n                if (columnMax[col] <= currentRow) {\n                    if (newBlock.length == 0) {\n                        newBlock.start = col;\n                    }\n                    newBlock.length++;\n                    newBlock.end = col + 1;\n                }\n                else if (newBlock.length > 0) {\n                    columns.push(newBlock);\n                    newBlock = {\n                        start: col,\n                        end: col,\n                        length: 0,\n                    };\n                }\n            }\n            if (newBlock.length > 0) {\n                columns.push(newBlock);\n            }\n            var tempColumns = columns.map(function (block) { return block.length; });\n            var currentItems = [];\n            while (items.length > 0) {\n                var item = items[0];\n                if (item.row > currentRow)\n                    break;\n                var fits = false;\n                for (var x in tempColumns) {\n                    if (item.sizex <= tempColumns[x]) {\n                        tempColumns[x] -= item.sizex;\n                        fits = true;\n                        break;\n                    }\n                    else if (item.sizex > tempColumns[x]) {\n                        tempColumns[x] = 0;\n                    }\n                }\n                if (fits) {\n                    currentItems.push(items.shift());\n                }\n                else {\n                    break;\n                }\n            }\n            if (currentItems.length > 0) {\n                var itemPositions = [];\n                var lastPosition = maxCols;\n                for (var i = currentItems.length - 1; i >= 0; i--) {\n                    var maxPosition = 1;\n                    for (var j = columns.length - 1; j >= 0; j--) {\n                        if (columns[j].start > lastPosition)\n                            continue;\n                        if (columns[j].start > (maxCols - currentItems[i].sizex))\n                            continue;\n                        if (columns[j].length < currentItems[i].sizex)\n                            continue;\n                        if (lastPosition < columns[j].end && (lastPosition - columns[j].start) < currentItems[i].sizex)\n                            continue;\n                        maxPosition = (lastPosition < columns[j].end ? lastPosition : columns[j].end) - currentItems[i].sizex;\n                        break;\n                    }\n                    itemPositions[i] = Math.min(maxPosition, currentItems[i].row == currentRow ? currentItems[i].col : 1);\n                    lastPosition = itemPositions[i];\n                }\n                var minPosition = 1;\n                var currentItem = 0;\n                while (currentItems.length > 0) {\n                    var item = currentItems.shift();\n                    for (var j = 0; j < columns.length; j++) {\n                        if (columns[j].length < item.sizex)\n                            continue;\n                        if (minPosition > columns[j].end)\n                            continue;\n                        if (minPosition > columns[j].start && (columns[j].end - minPosition) < item.sizex)\n                            continue;\n                        if (minPosition < columns[j].start)\n                            minPosition = columns[j].start;\n                        break;\n                    }\n                    item.setGridPosition({ col: Math.max(minPosition, itemPositions[currentItem]), row: currentRow });\n                    minPosition = item.currentCol + item.sizex;\n                    currentItem++;\n                    for (var i = item.currentCol; i < item.currentCol + item.sizex; i++) {\n                        columnMax[i] = item.currentRow + item.sizey;\n                    }\n                }\n            }\n            else if (currentItems.length === 0 && columns.length === 1 && columns[0].length >= maxCols) {\n                var item = items.shift();\n                item.setGridPosition({ col: 1, row: currentRow });\n                for (var i = item.currentCol; i < item.currentCol + item.sizex; i++) {\n                    columnMax[i] = item.currentRow + item.sizey;\n                }\n            }\n            var newRow = 0;\n            for (var x in columnMax) {\n                if (columnMax[x] > currentRow && (newRow == 0 || columnMax[x] < newRow)) {\n                    newRow = columnMax[x];\n                }\n            }\n            currentRow = newRow <= currentRow ? currentRow + 1 : newRow;\n        }\n    };\n    NgGrid.prototype._cascadeGrid = function (pos, dims, shouldSave) {\n        if (shouldSave === void 0) { shouldSave = true; }\n        if (this._destroyed)\n            return;\n        if (pos && !dims)\n            throw new Error('Cannot cascade with only position and not dimensions');\n        if (this.isDragging && this._draggingItem && !pos && !dims) {\n            pos = this._draggingItem.getGridPosition();\n            dims = this._draggingItem.getSize();\n        }\n        else if (this.isResizing && this._resizingItem && !pos && !dims) {\n            pos = this._resizingItem.getGridPosition();\n            dims = this._resizingItem.getSize();\n        }\n        switch (this.cascade) {\n            case 'up':\n            case 'down':\n                var lowRow = [0];\n                for (var i = 1; i <= this._curMaxCol; i++)\n                    lowRow[i] = 1;\n                for (var r = 1; r <= this._curMaxRow; r++) {\n                    if (this._itemGrid[r] == undefined)\n                        continue;\n                    for (var c = 1; c <= this._curMaxCol; c++) {\n                        if (this._itemGrid[r] == undefined)\n                            break;\n                        if (r < lowRow[c])\n                            continue;\n                        if (this._itemGrid[r][c] != null) {\n                            var item = this._itemGrid[r][c];\n                            if (item.isFixed)\n                                continue;\n                            var itemDims = item.getSize();\n                            var itemPos = item.getGridPosition();\n                            if (itemPos.col != c || itemPos.row != r)\n                                continue; //\tIf this is not the element's start\n                            var lowest = lowRow[c];\n                            for (var i = 1; i < itemDims.x; i++) {\n                                lowest = Math.max(lowRow[(c + i)], lowest);\n                            }\n                            if (pos && (c + itemDims.x) > pos.col && c < (pos.col + dims.x)) {\n                                if ((r >= pos.row && r < (pos.row + dims.y)) ||\n                                    ((itemDims.y > (pos.row - lowest)) &&\n                                        (r >= (pos.row + dims.y) && lowest < (pos.row + dims.y)))) {\n                                    lowest = Math.max(lowest, pos.row + dims.y); //\tSet the lowest row to be below it\n                                }\n                            }\n                            var newPos = { col: c, row: lowest };\n                            if (lowest != itemPos.row && this._isWithinBoundsY(newPos, itemDims)) {\n                                this._removeFromGrid(item);\n                                if (shouldSave) {\n                                    item.savePosition(newPos);\n                                }\n                                else {\n                                    item.setGridPosition(newPos);\n                                }\n                                item.onCascadeEvent();\n                                this._addToGrid(item);\n                            }\n                            for (var i = 0; i < itemDims.x; i++) {\n                                lowRow[c + i] = lowest + itemDims.y; //\tUpdate the lowest row to be below the item\n                            }\n                        }\n                    }\n                }\n                break;\n            case 'left':\n            case 'right':\n                var lowCol = [0];\n                for (var i = 1; i <= this._curMaxRow; i++)\n                    lowCol[i] = 1;\n                for (var r = 1; r <= this._curMaxRow; r++) {\n                    if (this._itemGrid[r] == undefined)\n                        continue;\n                    for (var c = 1; c <= this._curMaxCol; c++) {\n                        if (this._itemGrid[r] == undefined)\n                            break;\n                        if (c < lowCol[r])\n                            continue;\n                        if (this._itemGrid[r][c] != null) {\n                            var item = this._itemGrid[r][c];\n                            var itemDims = item.getSize();\n                            var itemPos = item.getGridPosition();\n                            if (itemPos.col != c || itemPos.row != r)\n                                continue; //\tIf this is not the element's start\n                            var lowest = lowCol[r];\n                            for (var i = 1; i < itemDims.y; i++) {\n                                lowest = Math.max(lowCol[(r + i)], lowest);\n                            }\n                            if (pos && (r + itemDims.y) > pos.row && r < (pos.row + dims.y)) {\n                                if ((c >= pos.col && c < (pos.col + dims.x)) ||\n                                    ((itemDims.x > (pos.col - lowest)) &&\n                                        (c >= (pos.col + dims.x) && lowest < (pos.col + dims.x)))) {\n                                    lowest = Math.max(lowest, pos.col + dims.x); //\tSet the lowest col to be below it\n                                }\n                            }\n                            var newPos = { col: lowest, row: r };\n                            if (lowest != itemPos.col && this._isWithinBoundsX(newPos, itemDims)) {\n                                this._removeFromGrid(item);\n                                if (shouldSave) {\n                                    item.savePosition(newPos);\n                                }\n                                else {\n                                    item.setGridPosition(newPos);\n                                }\n                                item.onCascadeEvent();\n                                this._addToGrid(item);\n                            }\n                            for (var i = 0; i < itemDims.y; i++) {\n                                lowCol[r + i] = lowest + itemDims.x; //\tUpdate the lowest col to be below the item\n                            }\n                        }\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    };\n    NgGrid.prototype._fixGridPosition = function (pos, dims) {\n        while (this._hasGridCollision(pos, dims) || !this._isWithinBounds(pos, dims)) {\n            if (this._hasGridCollision(pos, dims)) {\n                switch (this.cascade) {\n                    case 'up':\n                    case 'down':\n                    default:\n                        pos.row++;\n                        break;\n                    case 'left':\n                    case 'right':\n                        pos.col++;\n                        break;\n                }\n            }\n            if (!this._isWithinBoundsY(pos, dims)) {\n                pos.col++;\n                pos.row = 1;\n            }\n            if (!this._isWithinBoundsX(pos, dims)) {\n                pos.row++;\n                pos.col = 1;\n            }\n        }\n        return pos;\n    };\n    NgGrid.prototype._isWithinBoundsX = function (pos, dims) {\n        if (this._limitToScreen) {\n            return (pos.col + dims.x - 1) <= this._getContainerColumns();\n        }\n        else {\n            return (this._maxCols == 0 || (pos.col + dims.x - 1) <= this._maxCols);\n        }\n    };\n    NgGrid.prototype._isWithinBoundsY = function (pos, dims) {\n        return (this._maxRows == 0 || (pos.row + dims.y - 1) <= this._maxRows);\n    };\n    NgGrid.prototype._isWithinBounds = function (pos, dims) {\n        return this._isWithinBoundsX(pos, dims) && this._isWithinBoundsY(pos, dims);\n    };\n    NgGrid.prototype._addToGrid = function (item) {\n        var pos = item.getGridPosition();\n        var dims = item.getSize();\n        if (this._hasGridCollision(pos, dims)) {\n            this._fixGridCollisions(pos, dims);\n            pos = item.getGridPosition();\n        }\n        for (var j = 0; j < dims.y; j++) {\n            if (this._itemGrid[pos.row + j] == null)\n                this._itemGrid[pos.row + j] = {};\n            for (var i = 0; i < dims.x; i++) {\n                this._itemGrid[pos.row + j][pos.col + i] = item;\n                this._updateSize(pos.col + dims.x - 1, pos.row + dims.y - 1);\n            }\n        }\n    };\n    NgGrid.prototype._removeFromGrid = function (item) {\n        for (var y in this._itemGrid)\n            for (var x in this._itemGrid[y])\n                if (this._itemGrid[y][x] == item)\n                    delete this._itemGrid[y][x];\n    };\n    NgGrid.prototype._updateSize = function (col, row) {\n        if (this._destroyed)\n            return;\n        col = (col == undefined) ? this._getMaxCol() : col;\n        row = (row == undefined) ? this._getMaxRow() : row;\n        var maxCol = Math.max(this._curMaxCol, col);\n        var maxRow = Math.max(this._curMaxRow, row);\n        if (maxCol != this._curMaxCol || maxRow != this._curMaxRow) {\n            this._curMaxCol = maxCol;\n            this._curMaxRow = maxRow;\n        }\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'width', '100%'); //(maxCol * (this.colWidth + this.marginLeft + this.marginRight))+'px');\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'height', (this._getMaxRow() * (this.rowHeight + this.marginTop + this.marginBottom)) + 'px');\n    };\n    NgGrid.prototype._getMaxRow = function () {\n        return Math.max.apply(null, this._items.map(function (item) { return item.getGridPosition().row + item.getSize().y - 1; }));\n    };\n    NgGrid.prototype._getMaxCol = function () {\n        return Math.max.apply(null, this._items.map(function (item) { return item.getGridPosition().col + item.getSize().x - 1; }));\n    };\n    NgGrid.prototype._getMousePosition = function (e) {\n        if ((window.TouchEvent && e instanceof TouchEvent) || (e.touches || e.changedTouches)) {\n            e = e.touches.length > 0 ? e.touches[0] : e.changedTouches[0];\n        }\n        var refPos = this._ngEl.nativeElement.getBoundingClientRect();\n        var left = e.clientX - refPos.left;\n        var top = e.clientY - refPos.top;\n        if (this.cascade == 'down')\n            top = refPos.top + refPos.height - e.clientY;\n        if (this.cascade == 'right')\n            left = refPos.left + refPos.width - e.clientX;\n        if (this.isDragging && this._zoomOnDrag) {\n            left *= 2;\n            top *= 2;\n        }\n        return {\n            left: left,\n            top: top\n        };\n    };\n    NgGrid.prototype._getAbsoluteMousePosition = function (e) {\n        if ((window.TouchEvent && e instanceof TouchEvent) || (e.touches || e.changedTouches)) {\n            e = e.touches.length > 0 ? e.touches[0] : e.changedTouches[0];\n        }\n        return {\n            left: e.clientX,\n            top: e.clientY\n        };\n    };\n    NgGrid.prototype._getContainerColumns = function () {\n        var maxWidth = this._ngEl.nativeElement.getBoundingClientRect().width;\n        return Math.floor(maxWidth / (this.colWidth + this.marginLeft + this.marginRight));\n    };\n    NgGrid.prototype._getItemFromPosition = function (position) {\n        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {\n            var item = _a[_i];\n            var size = item.getDimensions();\n            var pos = item.getPosition();\n            if (position.left > (pos.left + this.marginLeft) && position.left < (pos.left + this.marginLeft + size.width) &&\n                position.top > (pos.top + this.marginTop) && position.top < (pos.top + this.marginTop + size.height)) {\n                return item;\n            }\n        }\n        return null;\n    };\n    NgGrid.prototype._createPlaceholder = function (item) {\n        var pos = item.getGridPosition();\n        var dims = item.getSize();\n        var factory = this.componentFactoryResolver.resolveComponentFactory(NgGridPlaceholder);\n        var componentRef = item.containerRef.createComponent(factory);\n        this._placeholderRef = componentRef;\n        var placeholder = componentRef.instance;\n        placeholder.registerGrid(this);\n        placeholder.setCascadeMode(this.cascade);\n        placeholder.setGridPosition({ col: pos.col, row: pos.row });\n        placeholder.setSize({ x: dims.x, y: dims.y });\n    };\n    NgGrid.prototype._emitOnItemChange = function () {\n        this.onItemChange.emit(this._items.map(function (item) { return item.getEventOutput(); }));\n    };\n    //\tDefault config\n    NgGrid.CONST_DEFAULT_CONFIG = {\n        margins: [10],\n        draggable: true,\n        resizable: true,\n        max_cols: 0,\n        max_rows: 0,\n        visible_cols: 0,\n        visible_rows: 0,\n        col_width: 250,\n        row_height: 250,\n        cascade: 'up',\n        min_width: 100,\n        min_height: 100,\n        fix_to_grid: false,\n        auto_style: true,\n        auto_resize: false,\n        maintain_ratio: false,\n        prefer_new: false,\n        zoom_on_drag: false\n    };\n    NgGrid.decorators = [\n        { type: Directive, args: [{\n                    selector: '[ngGrid]',\n                    inputs: ['config: ngGrid'],\n                    host: {\n                        '(mousedown)': 'mouseDownEventHandler($event)',\n                        '(mousemove)': 'mouseMoveEventHandler($event)',\n                        '(mouseup)': 'mouseUpEventHandler($event)',\n                        '(touchstart)': 'mouseDownEventHandler($event)',\n                        '(touchmove)': 'mouseMoveEventHandler($event)',\n                        '(touchend)': 'mouseUpEventHandler($event)',\n                        '(window:resize)': 'resizeEventHandler($event)',\n                        '(document:mousemove)': 'mouseMoveEventHandler($event)',\n                        '(document:mouseup)': 'mouseUpEventHandler($event)'\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    NgGrid.ctorParameters = function () { return [\n        { type: KeyValueDiffers, },\n        { type: ElementRef, },\n        { type: Renderer, },\n        { type: ComponentFactoryResolver, },\n        { type: ViewContainerRef, },\n    ]; };\n    NgGrid.propDecorators = {\n        'onDragStart': [{ type: Output },],\n        'onDrag': [{ type: Output },],\n        'onDragStop': [{ type: Output },],\n        'onResizeStart': [{ type: Output },],\n        'onResize': [{ type: Output },],\n        'onResizeStop': [{ type: Output },],\n        'onItemChange': [{ type: Output },],\n    };\n    return NgGrid;\n}());\n//# sourceMappingURL=NgGrid.js.map","/home/travis/build/npmtest/node-npmtest-angular2-grid/node_modules/angular2-grid/directives/NgGridItem.js":"import { NgGrid } from './NgGrid';\nimport { Directive, ElementRef, Renderer, EventEmitter, KeyValueDiffers, ViewContainerRef, Output } from '@angular/core';\nexport var NgGridItem = (function () {\n    //\tConstructor\n    function NgGridItem(_differs, _ngEl, _renderer, _ngGrid, containerRef) {\n        this._differs = _differs;\n        this._ngEl = _ngEl;\n        this._renderer = _renderer;\n        this._ngGrid = _ngGrid;\n        this.containerRef = containerRef;\n        //\tEvent Emitters\n        this.onItemChange = new EventEmitter(false);\n        this.onDragStart = new EventEmitter();\n        this.onDrag = new EventEmitter();\n        this.onDragStop = new EventEmitter();\n        this.onDragAny = new EventEmitter();\n        this.onResizeStart = new EventEmitter();\n        this.onResize = new EventEmitter();\n        this.onResizeStop = new EventEmitter();\n        this.onResizeAny = new EventEmitter();\n        this.onChangeStart = new EventEmitter();\n        this.onChange = new EventEmitter();\n        this.onChangeStop = new EventEmitter();\n        this.onChangeAny = new EventEmitter();\n        this.ngGridItemChange = new EventEmitter();\n        this.isFixed = false;\n        this.isDraggable = true;\n        this.isResizable = true;\n        this.minWidth = 0;\n        this.minHeight = 0;\n        this._position = { col: 1, row: 1 };\n        this._currentPosition = { col: 1, row: 1 };\n        this._size = { x: 1, y: 1 };\n        this._config = NgGridItem.CONST_DEFAULT_CONFIG;\n        this._added = false;\n        this._maxCols = 0;\n        this._minCols = 0;\n        this._maxRows = 0;\n        this._minRows = 0;\n    }\n    Object.defineProperty(NgGridItem.prototype, \"config\", {\n        //\t[ng-grid-item] handler\n        set: function (v) {\n            var defaults = NgGridItem.CONST_DEFAULT_CONFIG;\n            for (var x in defaults)\n                if (v[x] == null)\n                    v[x] = defaults[x];\n            this.setConfig(v);\n            if (this._differ == null && v != null) {\n                this._differ = this._differs.find(this._config).create(null);\n            }\n            if (!this._added) {\n                this._added = true;\n                this._ngGrid.addItem(this);\n            }\n            this._recalculateDimensions();\n            this._recalculatePosition();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"sizex\", {\n        get: function () {\n            return this._size.x;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"sizey\", {\n        get: function () {\n            return this._size.y;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"col\", {\n        get: function () {\n            return this._position.col;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"row\", {\n        get: function () {\n            return this._position.row;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"currentCol\", {\n        get: function () {\n            return this._currentPosition.col;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgGridItem.prototype, \"currentRow\", {\n        get: function () {\n            return this._currentPosition.row;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NgGridItem.prototype.onResizeStartEvent = function () {\n        var event = this.getEventOutput();\n        this.onResizeStart.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChangeStart.emit(event);\n        this.onChangeAny.emit(event);\n    };\n    NgGridItem.prototype.onResizeEvent = function () {\n        var event = this.getEventOutput();\n        this.onResize.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChange.emit(event);\n        this.onChangeAny.emit(event);\n    };\n    NgGridItem.prototype.onResizeStopEvent = function () {\n        var event = this.getEventOutput();\n        this.onResizeStop.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChangeStop.emit(event);\n        this.onChangeAny.emit(event);\n        this._config.sizex = this._size.x;\n        this._config.sizey = this._size.y;\n        this.ngGridItemChange.emit(this._config);\n    };\n    NgGridItem.prototype.onDragStartEvent = function () {\n        var event = this.getEventOutput();\n        this.onDragStart.emit(event);\n        this.onDragAny.emit(event);\n        this.onChangeStart.emit(event);\n        this.onChangeAny.emit(event);\n    };\n    NgGridItem.prototype.onDragEvent = function () {\n        var event = this.getEventOutput();\n        this.onDrag.emit(event);\n        this.onDragAny.emit(event);\n        this.onChange.emit(event);\n        this.onChangeAny.emit(event);\n    };\n    NgGridItem.prototype.onDragStopEvent = function () {\n        var event = this.getEventOutput();\n        this.onDragStop.emit(event);\n        this.onDragAny.emit(event);\n        this.onChangeStop.emit(event);\n        this.onChangeAny.emit(event);\n        this._config.col = this._position.col;\n        this._config.row = this._position.row;\n        this.ngGridItemChange.emit(this._config);\n    };\n    NgGridItem.prototype.onCascadeEvent = function () {\n        this._config.sizex = this._size.x;\n        this._config.sizey = this._size.y;\n        this._config.col = this._position.col;\n        this._config.row = this._position.row;\n        this.ngGridItemChange.emit(this._config);\n    };\n    NgGridItem.prototype.ngOnInit = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'grid-item', true);\n        if (this._ngGrid.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'position', 'absolute');\n        this._recalculateDimensions();\n        this._recalculatePosition();\n        if (!this._added) {\n            this._added = true;\n            this._ngGrid.addItem(this);\n        }\n    };\n    //\tPublic methods\n    NgGridItem.prototype.canDrag = function (e) {\n        if (!this.isDraggable)\n            return false;\n        if (this._dragHandle) {\n            return this.findHandle(this._dragHandle, e.target);\n        }\n        return true;\n    };\n    NgGridItem.prototype.findHandle = function (handleSelector, startElement) {\n        var targetElem = startElement;\n        while (targetElem && targetElem != this._ngEl.nativeElement) {\n            if (this.elementMatches(targetElem, handleSelector))\n                return true;\n            targetElem = targetElem.parentElement;\n        }\n        return false;\n    };\n    NgGridItem.prototype.canResize = function (e) {\n        if (!this.isResizable)\n            return null;\n        if (this._resizeHandle) {\n            return this.findHandle(this._resizeHandle, e.target) ? 'both' : null;\n        }\n        var mousePos = this._getMousePosition(e);\n        if (mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize\n            && mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize) {\n            return 'both';\n        }\n        else if (mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize) {\n            return 'width';\n        }\n        else if (mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize) {\n            return 'height';\n        }\n        return null;\n    };\n    NgGridItem.prototype.onMouseMove = function (e) {\n        if (this._ngGrid.autoStyle) {\n            if (this._ngGrid.resizeEnable && !this._resizeHandle && this.isResizable) {\n                var mousePos = this._getMousePosition(e);\n                if (mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize\n                    && mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize) {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'nwse-resize');\n                }\n                else if (mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize) {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'ew-resize');\n                }\n                else if (mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize) {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'ns-resize');\n                }\n                else if (this._ngGrid.dragEnable && this.canDrag(e)) {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'move');\n                }\n                else {\n                    this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'default');\n                }\n            }\n            else if (this._ngGrid.resizeEnable && this.canResize(e)) {\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'nwse-resize');\n            }\n            else if (this._ngGrid.dragEnable && this.canDrag(e)) {\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'move');\n            }\n            else {\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'cursor', 'default');\n            }\n        }\n    };\n    NgGridItem.prototype.ngOnDestroy = function () {\n        if (this._added)\n            this._ngGrid.removeItem(this);\n    };\n    //\tGetters\n    NgGridItem.prototype.getElement = function () {\n        return this._ngEl;\n    };\n    NgGridItem.prototype.getDragHandle = function () {\n        return this._dragHandle;\n    };\n    NgGridItem.prototype.getResizeHandle = function () {\n        return this._resizeHandle;\n    };\n    NgGridItem.prototype.getDimensions = function () {\n        return { 'width': this._elemWidth, 'height': this._elemHeight };\n    };\n    NgGridItem.prototype.getSize = function () {\n        return this._size;\n    };\n    NgGridItem.prototype.getPosition = function () {\n        return { 'left': this._elemLeft, 'top': this._elemTop };\n    };\n    NgGridItem.prototype.getGridPosition = function () {\n        return this._currentPosition;\n    };\n    NgGridItem.prototype.getSavedPosition = function () {\n        return this._position;\n    };\n    //\tSetters\n    NgGridItem.prototype.setConfig = function (config) {\n        this._config = config;\n        this._payload = config.payload;\n        this._position.col = this._currentPosition.col = config.col ? config.col : NgGridItem.CONST_DEFAULT_CONFIG.col;\n        this._position.row = this._currentPosition.row = config.row ? config.row : NgGridItem.CONST_DEFAULT_CONFIG.row;\n        this._size.x = config.sizex ? config.sizex : NgGridItem.CONST_DEFAULT_CONFIG.sizex;\n        this._size.y = config.sizey ? config.sizey : NgGridItem.CONST_DEFAULT_CONFIG.sizey;\n        this._dragHandle = config.dragHandle;\n        this._resizeHandle = config.resizeHandle;\n        this._borderSize = config.borderSize;\n        this.isDraggable = config.draggable ? true : false;\n        this.isResizable = config.resizable ? true : false;\n        this.isFixed = config.fixed ? true : false;\n        this._maxCols = !isNaN(config.maxCols) && isFinite(config.maxCols) ? config.maxCols : 0;\n        this._minCols = !isNaN(config.minCols) && isFinite(config.minCols) ? config.minCols : 0;\n        this._maxRows = !isNaN(config.maxRows) && isFinite(config.maxRows) ? config.maxRows : 0;\n        this._minRows = !isNaN(config.minRows) && isFinite(config.minRows) ? config.minRows : 0;\n        this.minWidth = !isNaN(config.minWidth) && isFinite(config.minWidth) ? config.minWidth : 0;\n        this.minHeight = !isNaN(config.minHeight) && isFinite(config.minHeight) ? config.minHeight : 0;\n        if (this._minCols > 0 && this._maxCols > 0 && this._minCols > this._maxCols)\n            this._minCols = 0;\n        if (this._minRows > 0 && this._maxRows > 0 && this._minRows > this._maxRows)\n            this._minRows = 0;\n        if (this._added) {\n            this._ngGrid.updateItem(this);\n        }\n        this._size = this.fixResize(this._size);\n        this._recalculatePosition();\n        this._recalculateDimensions();\n    };\n    NgGridItem.prototype.ngDoCheck = function () {\n        if (this._differ != null) {\n            var changes = this._differ.diff(this._config);\n            if (changes != null) {\n                this._applyChanges(changes);\n                return true;\n            }\n        }\n        return false;\n    };\n    NgGridItem.prototype.setSize = function (newSize, update) {\n        if (update === void 0) { update = true; }\n        newSize = this.fixResize(newSize);\n        this._size = newSize;\n        if (update)\n            this._recalculateDimensions();\n        this.onItemChange.emit(this.getEventOutput());\n    };\n    NgGridItem.prototype.setGridPosition = function (gridPosition, update) {\n        if (update === void 0) { update = true; }\n        this._currentPosition = gridPosition;\n        if (update)\n            this._recalculatePosition();\n        this.onItemChange.emit(this.getEventOutput());\n    };\n    NgGridItem.prototype.savePosition = function (newPosition) {\n        this._position = newPosition;\n        this._currentPosition = newPosition;\n        this._recalculatePosition();\n        this.onItemChange.emit(this.getEventOutput());\n    };\n    NgGridItem.prototype.getEventOutput = function () {\n        return {\n            payload: this._payload,\n            col: this._currentPosition.col,\n            row: this._currentPosition.row,\n            sizex: this._size.x,\n            sizey: this._size.y,\n            width: this._elemWidth,\n            height: this._elemHeight,\n            left: this._elemLeft,\n            top: this._elemTop\n        };\n    };\n    NgGridItem.prototype.setPosition = function (x, y) {\n        switch (this._cascadeMode) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + y + 'px)');\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + -x + 'px, ' + y + 'px)');\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + -y + 'px)');\n                break;\n        }\n        this._elemLeft = x;\n        this._elemTop = y;\n    };\n    NgGridItem.prototype.setCascadeMode = function (cascade) {\n        this._cascadeMode = cascade;\n        switch (cascade) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', null);\n                break;\n        }\n    };\n    NgGridItem.prototype.setDimensions = function (w, h) {\n        if (w < this.minWidth)\n            w = this.minWidth;\n        if (h < this.minHeight)\n            h = this.minHeight;\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'width', w + 'px');\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'height', h + 'px');\n        this._elemWidth = w;\n        this._elemHeight = h;\n    };\n    NgGridItem.prototype.startMoving = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'moving', true);\n        var style = window.getComputedStyle(this._ngEl.nativeElement);\n        if (this._ngGrid.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'z-index', (parseInt(style.getPropertyValue('z-index')) + 1).toString());\n    };\n    NgGridItem.prototype.stopMoving = function () {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'moving', false);\n        var style = window.getComputedStyle(this._ngEl.nativeElement);\n        if (this._ngGrid.autoStyle)\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'z-index', (parseInt(style.getPropertyValue('z-index')) - 1).toString());\n    };\n    NgGridItem.prototype.recalculateSelf = function () {\n        this._recalculatePosition();\n        this._recalculateDimensions();\n    };\n    NgGridItem.prototype.fixResize = function (newSize) {\n        if (this._maxCols > 0 && newSize.x > this._maxCols)\n            newSize.x = this._maxCols;\n        if (this._maxRows > 0 && newSize.y > this._maxRows)\n            newSize.y = this._maxRows;\n        if (this._minCols > 0 && newSize.x < this._minCols)\n            newSize.x = this._minCols;\n        if (this._minRows > 0 && newSize.y < this._minRows)\n            newSize.y = this._minRows;\n        var itemWidth = (newSize.x * this._ngGrid.colWidth) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (newSize.x - 1));\n        if (itemWidth < this.minWidth)\n            newSize.x = Math.ceil((this.minWidth + this._ngGrid.marginRight + this._ngGrid.marginLeft) / (this._ngGrid.colWidth + this._ngGrid.marginRight + this._ngGrid.marginLeft));\n        var itemHeight = (newSize.y * this._ngGrid.rowHeight) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (newSize.y - 1));\n        if (itemHeight < this.minHeight)\n            newSize.y = Math.ceil((this.minHeight + this._ngGrid.marginBottom + this._ngGrid.marginTop) / (this._ngGrid.rowHeight + this._ngGrid.marginBottom + this._ngGrid.marginTop));\n        return newSize;\n    };\n    //\tPrivate methods\n    NgGridItem.prototype.elementMatches = function (element, selector) {\n        if (element.matches)\n            return element.matches(selector);\n        if (element.oMatchesSelector)\n            return element.oMatchesSelector(selector);\n        if (element.msMatchesSelector)\n            return element.msMatchesSelector(selector);\n        if (element.mozMatchesSelector)\n            return element.mozMatchesSelector(selector);\n        if (element.webkitMatchesSelector)\n            return element.webkitMatchesSelector(selector);\n        var matches = (element.document || element.ownerDocument).querySelectorAll(selector);\n        var i = matches.length;\n        while (--i >= 0 && matches.item(i) !== element) { }\n        return i > -1;\n    };\n    NgGridItem.prototype._recalculatePosition = function () {\n        var x = (this._ngGrid.colWidth + this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._currentPosition.col - 1) + this._ngGrid.marginLeft;\n        var y = (this._ngGrid.rowHeight + this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._currentPosition.row - 1) + this._ngGrid.marginTop;\n        this.setPosition(x, y);\n    };\n    NgGridItem.prototype._recalculateDimensions = function () {\n        if (this._size.x < this._ngGrid.minCols)\n            this._size.x = this._ngGrid.minCols;\n        if (this._size.y < this._ngGrid.minRows)\n            this._size.y = this._ngGrid.minRows;\n        var newWidth = (this._ngGrid.colWidth * this._size.x) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._size.x - 1));\n        var newHeight = (this._ngGrid.rowHeight * this._size.y) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._size.y - 1));\n        var w = Math.max(this.minWidth, this._ngGrid.minWidth, newWidth);\n        var h = Math.max(this.minHeight, this._ngGrid.minHeight, newHeight);\n        this.setDimensions(w, h);\n    };\n    NgGridItem.prototype._getMousePosition = function (e) {\n        if (e.originalEvent && e.originalEvent.touches) {\n            var oe = e.originalEvent;\n            e = oe.touches.length ? oe.touches[0] : (oe.changedTouches.length ? oe.changedTouches[0] : e);\n        }\n        else if (e.touches) {\n            e = e.touches.length ? e.touches[0] : (e.changedTouches.length ? e.changedTouches[0] : e);\n        }\n        var refPos = this._ngEl.nativeElement.getBoundingClientRect();\n        return {\n            left: e.clientX - refPos.left,\n            top: e.clientY - refPos.top\n        };\n    };\n    NgGridItem.prototype._applyChanges = function (changes) {\n        var _this = this;\n        changes.forEachAddedItem(function (record) { _this._config[record.key] = record.currentValue; });\n        changes.forEachChangedItem(function (record) { _this._config[record.key] = record.currentValue; });\n        changes.forEachRemovedItem(function (record) { delete _this._config[record.key]; });\n        this.setConfig(this._config);\n    };\n    //\tDefault config\n    NgGridItem.CONST_DEFAULT_CONFIG = {\n        col: 1,\n        row: 1,\n        sizex: 1,\n        sizey: 1,\n        dragHandle: null,\n        resizeHandle: null,\n        fixed: false,\n        draggable: true,\n        resizable: true,\n        borderSize: 25\n    };\n    NgGridItem.decorators = [\n        { type: Directive, args: [{\n                    selector: '[ngGridItem]',\n                    inputs: ['config: ngGridItem']\n                },] },\n    ];\n    /** @nocollapse */\n    NgGridItem.ctorParameters = function () { return [\n        { type: KeyValueDiffers, },\n        { type: ElementRef, },\n        { type: Renderer, },\n        { type: NgGrid, },\n        { type: ViewContainerRef, },\n    ]; };\n    NgGridItem.propDecorators = {\n        'onItemChange': [{ type: Output },],\n        'onDragStart': [{ type: Output },],\n        'onDrag': [{ type: Output },],\n        'onDragStop': [{ type: Output },],\n        'onDragAny': [{ type: Output },],\n        'onResizeStart': [{ type: Output },],\n        'onResize': [{ type: Output },],\n        'onResizeStop': [{ type: Output },],\n        'onResizeAny': [{ type: Output },],\n        'onChangeStart': [{ type: Output },],\n        'onChange': [{ type: Output },],\n        'onChangeStop': [{ type: Output },],\n        'onChangeAny': [{ type: Output },],\n        'ngGridItemChange': [{ type: Output },],\n    };\n    return NgGridItem;\n}());\n//# sourceMappingURL=NgGridItem.js.map","/home/travis/build/npmtest/node-npmtest-angular2-grid/node_modules/angular2-grid/interfaces/INgGrid.js":"//# sourceMappingURL=INgGrid.js.map","/home/travis/build/npmtest/node-npmtest-angular2-grid/node_modules/angular2-grid/main.js":"export * from './directives/NgGrid';\nexport * from './directives/NgGridItem';\nexport * from './components/NgGridPlaceholder';\nexport * from './interfaces/INgGrid';\nexport * from './modules/NgGrid.module';\n//# sourceMappingURL=main.js.map","/home/travis/build/npmtest/node-npmtest-angular2-grid/node_modules/angular2-grid/modules/NgGrid.module.js":"import { NgModule } from '@angular/core';\nimport { NgGrid, NgGridItem, NgGridPlaceholder } from '../main';\nexport var NgGridModule = (function () {\n    function NgGridModule() {\n    }\n    NgGridModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [NgGrid, NgGridItem, NgGridPlaceholder],\n                    entryComponents: [NgGridPlaceholder],\n                    exports: [NgGrid, NgGridItem]\n                },] },\n    ];\n    /** @nocollapse */\n    NgGridModule.ctorParameters = function () { return []; };\n    return NgGridModule;\n}());\n//# sourceMappingURL=NgGrid.module.js.map"}